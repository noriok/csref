<?xml version="1.0"?>
<cs>
    <class name="Math">
        <url>https://msdn.microsoft.com/ja-jp/library/system.math%28v=vs.110%29.aspx</url>
        <namespace>System</namespace>

        <field name="E">
            <desc></desc>
        </field>

        <field name="PI">
        </field>

        <static-method name="Abs">
            <sig>decimal (decimal x)</sig>
            <sig>double (double x)</sig>
            <sig>short (short x)</sig>
            <sig>int (int x)</sig>
            <sig>long (long x)</sig>
            <sig>sbyte (sbyte x)</sig>
            <sig>float (float x)</sig>
            <desc>
                x の絶対値を計算します。
            </desc>
            <example>
csharp> Math.Abs(-120);
120
csharp> Math.Abs(-120.4);
120.4
            </example>
        </static-method>

        <static-method name="Acos">
            <sig>double (double x)</sig>
        </static-method>

        <static-method name="Asin">
            <sig>double (double x)</sig>
        </static-method>

        <static-method name="Atan">
            <sig>double (double x)</sig>
        </static-method>

        <static-method name="Atan2">
            <sig>double (double y, double x)</sig>
        </static-method>

        <static-method name="BigMul">
            <sig>long (int a, int b)</sig>
            <desc>
                引数 a, b の積を計算します。
                オーバーフローせず、戻り値を long で返します。
            </desc>
            <example>
csharp> Math.BigMul(int.MaxValue, int.MaxValue);
4611686014132420609
            </example>
        </static-method>

        <static-method name="Ceiling">
            <sig>decimal (decimal x)</sig>
            <sig>double (double x)</sig>
            <desc>
                自身と等しいかより大きな整数のうち、最小のものを返します。
            </desc>
            <example>
csharp> Math.Ceiling(1.0);
1
csharp> Math.Ceiling(1.3);
2
csharp> Math.Ceiling(-1.3);
-1
            </example>
        </static-method>

        <static-method name="Cos">
            <sig>double (double x)</sig>
        </static-method>

        <static-method name="Cosh">
            <sig>double (double x)</sig>
        </static-method>

        <static-method name="DivRem">
            <sig>int (int a, int b, out int m)</sig>
            <sig>long (long a, long b, out long m)</sig>
            <desc>商と余りを求めます。</desc>
            <example>
csharp> var m = 0;
csharp> Math.DivRem(10, 3, out m);
3
csharp> m
1
            </example>
        </static-method>

        <static-method name="Exp">
            <sig>double (double x)</sig>
            <desc>
                自然対数の底 e の x 乗の値を返します。
            </desc>
            <example>
csharp> Math.Exp(1.0);
2.71828182845905
csharp> Math.Exp(2.0);
7.38905609893065
            </example>
        </static-method>

        <static-method name="Floor">
            <sig>decimal (decimal x)</sig>
            <sig>double (double x)</sig>
            <desc>
                自身と等しいか、より小さな整数のうち最大のものを返します。
            </desc>
            <example>
csharp> Math.Floor(1.0);
1
csharp> Math.Floor(1.3);
1
csharp> Math.Floor(-1.3);
-2
            </example>
        </static-method>

        <static-method name="IEEERemainder">
            <sig>double (double x, double y)</sig>
        </static-method>

        <static-method name="Log">
            <sig>double (double x)</sig>
            <sig>double (double x, double base)</sig>
        </static-method>

        <static-method name="Log10">
            <sig>double (double x)</sig>
        </static-method>

        <static-method name="Max">
            <sig>byte (byte a, byte b)</sig>
            <sig>decimal (decimal a, decimal b)</sig>
            <sig>double (double a, double b)</sig>
            <sig>short (short a, short b)</sig>
            <sig>int (int a, int b)</sig>
            <sig>long (long a, long b)</sig>
            <sig>sbyte (sbyte a, sbyte b)</sig>
            <sig>float (float a, float b)</sig>
            <sig>ushort (ushort a, ushrot b)</sig>
            <sig>uint (uint a, uint b)</sig>
            <sig>ulong (ulong a, ulong b)</sig>
        </static-method>

        <static-method name="Min">
            <sig>byte (byte a, byte b)</sig>
            <sig>decimal (decimal a, decimal b)</sig>
            <sig>double (double a, double b)</sig>
            <sig>short (short a, short b)</sig>
            <sig>int (int a, int b)</sig>
            <sig>long (long a, long b)</sig>
            <sig>sbyte (sbyte a, sbyte b)</sig>
            <sig>float (float a, float b)</sig>
            <sig>ushort (ushort a, ushrot b)</sig>
            <sig>uint (uint a, uint b)</sig>
            <sig>ulong (ulong a, ulong b)</sig>
        </static-method>

        <static-method name="Pow">
            <sig>double (double x, double y)</sig>
            <desc>
                x の y 乗を返します。
            </desc>
            <example>
csharp> Math.Pow(2, 0);
1
csharp> Math.Pow(2, 10);
1024
csharp> Math.Pow(2, -1);
0.5
            </example>
        </static-method>

        <static-method name="Round">
            <sig>decimal (decimal x)</sig>
            <sig>decimal (decimal x, int decimals)</sig>
            <sig>decimal (decimal x, int decimals, MidpointRounding mode)</sig>
            <sig>decimal (decimal x, MidpointRounding mode)</sig>
            <sig>double (double x)</sig>
            <sig>double (double x, int digits)</sig>
            <sig>double (double x, int digits, MidpointRounding mode)</sig>
            <sig>double (double x, MidpointRounding mode)</sig>
        </static-method>

        <static-method name="Sign">
            <sig>int (decimal x)</sig>
            <sig>int (double x)</sig>
            <sig>int (short x)</sig>
            <sig>int (int x)</sig>
            <sig>int (long x)</sig>
            <sig>int (sbyte x)</sig>
            <sig>int (float x)</sig>
        </static-method>

        <static-method name="Sin">
            <sig>double (double x)</sig>
        </static-method>

        <static-method name="Sinh">
            <sig>double (double x)</sig>
        </static-method>

        <static-method name="Sqrt">
            <sig>double (double x)</sig>
            <desc>
                x の平方根を返します。
            </desc>
            <example>
csharp> Math.Sqrt(9);
3
csharp> Math.Sqrt(2);
1.4142135623731
csharp> Math.Sqrt(3);
1.73205080756888
            </example>
        </static-method>

        <static-method name="Tan">
            <sig>double (double x)</sig>
        </static-method>

        <static-method name="Tanh">
            <sig>double (double x)</sig>
        </static-method>

        <static-method name="Truncate">
            <sig>decimal (decimal x)</sig>
            <sig>double (double x)</sig>
        </static-method>

    </class>

    <class name="List&lt;T&gt;">
        <url>https://msdn.microsoft.com/ja-jp/library/6sh2ey19%28v=vs.110%29.aspx</url>
        <namespace>System.Collections.Generic</namespace>

        <constructor>
            <sig>()</sig>
            <sig>(IEnumerable&lt;T&gt; xs)</sig>
            <sig>(int capacity)</sig>
        </constructor>

        <property name="Capacity">
        </property>

        <property name="Count">
        </property>

        <property name="Item">
        </property>

        <method name="Add">
        </method>

        <method name="AddRange">
            <sig>void (IEnumerable&lt;T&gt; xs)</sig>
            <desc>
                指定したシーケンスの要素を末尾に追加します。
            </desc>
            <example>
csharp> var xs = new List&lt;int&gt;();
csharp> xs.AddRange(new[] { 1, 2, 3 });
csharp> xs
{ 1, 2, 3 }
            </example>
        </method>

        <method name="AsReadOnly">
        </method>

        <method name="BinarySearch">
            <sig>int (T item)</sig>
            <sig>int (T item, IComparer&lt;T&gt; comparer)</sig>
            <sig>int (int index, int count, T item, IComparer&lt;T&gt; comparer)</sig>
        </method>

        <method name="Clear">
            <sig>void ()</sig>
            <desc>リストを空にします。</desc>
            <example>
csharp> var xs = new List&lt;int&gt;() { 1, 2, 3 };
csharp> xs.Count
3
csharp> xs.Clear();
csharp> xs.Count
0
            </example>
        </method>

        <method name="Contains">
            <sig>bool (T val)</sig>
            <desc>
                リストに val が含まれるなら true を返します。
            </desc>
            <example>
csharp> var xs = new List&lt;int&gt;() { 1, 2, 3 };
csharp> xs.Contains(2);
true
csharp> xs.Contains(10);
false
            </example>

        </method>

        <method name="ConvertAll">
            <sig>List&lt;TOutput&gt; &lt;TOutput&gt;(Converter&lt;T, TOutput&gt; converter)</sig>
            <desc>リストの要素を変換します。</desc>
            <example>
csharp> var xs = new List&lt;int&gt; { 1, 3, 5 };
csharp> xs.ConvertAll(e => e.ToString());
{ "1", "3", "5" }
            </example>
        </method>

        <method name="CopyTo">
            <sig>void (T[] dst)</sig>
            <sig>void (T[] dst, int dstIndex)</sig>
            <sig>void (int index, T[] dst, int dstIndex, int count)</sig>
        </method>

        <method name="Equals">
        </method>

        <method name="Exists">
            <sig>bool (Predicate&lt;T&gt; pred)</sig>
            <desc>
                pred にマッチする要素がリストに含まれるなら true を返します。
            </desc>
            <example>
csharp> var xs = new List&lt;int&gt;() { 1, -2, 3 };
csharp> xs.Exists(e => e == 2);
false
csharp> xs.Exists(e => Math.Abs(e) == 2);
true
            </example>
        </method>

        <method name="Finalize">
        </method>

        <method name="Find">
            <sig>T (Predicate&lt;T&gt; pred)</sig>
            <desc>
                pred にマッチする最初の要素を返します。
                見つからない場合は、T の既定値を返します。
            </desc>
            <example>
csharp> var ls = new List&lt;int&gt;() { 3, 22 };
csharp> ls.Find(e => e == 3);
3
csharp> ls.Find(e => e > 10);
22
csharp> ls.Find(e => e == 10); // int の既定値が返る
0
            </example>
        </method>

        <method name="FindAll">
            <sig>List&lt;T&gt; (Predicate&lt;T&gt; pred)</sig>
            <desc>
                pred にマッチする全ての要素をリストにして返します。
            </desc>
            <example>
csharp> var xs = new List&lt;int&gt;() { 1, 2, 3, 4, 5 };
csharp> xs.FindAll(e => e % 2 == 0);
{ 2, 4 }
            </example>
        </method>

        <method name="FindIndex">
            <sig>int (Predicate&gt;T&gt; pred)</sig>
            <sig>int (int startIndex, Predicate&lt;T&gt; pred)</sig>
            <sig>int (int startIndex, int count, Predicate&lt;T&gt; pred)</sig>
            <desc>
                pred にマッチする要素を検索します。
                最初に見つかる要素のインデックスを返します。
                見つからなければ -1 を返します。

                引数 startIndex: 検索の開始インデックス
                引数 count: 検索する要素数
            </desc>

            <example>
csharp> var xs = new List&lt;int&gt;() { 1, 2, 3, 4, 5 };
csharp> xs.FindIndex(e => e > 2);
2
csharp> xs.FindIndex(2, e => e > 3); // xs[2] 以降の要素を検索
3
csharp> xs.FindIndex(2, e => e &lt; 3); // xs[2] 以降で 3 より小さな要素は存在しない
-1
            </example>
        </method>

        <method name="FindLast">
            <sig>T (Predicate&lt;T&gt; pred)</sig>
        </method>

        <method name="FindLastIndex">
            <sig>int (int startIndex, int count, Predicate&lt;T&gt; pred)</sig>
            <sig>int (int startIndex, Predicate&lt;T&gt; pred)</sig>
            <sig>int (Predicate&lt;T&gt; pred)</sig>
        </method>

        <method name="ForEach">
            <sig>void (Action&lt;T&gt; action)</sig>
            <desc>リストのそれぞれの要素に action を適用します。</desc>
            <example>
csharp> var xs = new List&lt;int&gt;() { 10, 20, 30 };
csharp> xs.ForEach(Console.WriteLine);
10
20
30
            </example>
        </method>

        <method name="GetEnumerator">
        </method>

        <method name="GetHashCode">
        </method>

        <method name="GetRange">
            <sig>List&lt;T&gt; (int index, int count)</sig>
            <desc>
                リストのコピー(浅いコピー)を生成します。
            </desc>
            <example>
csharp> var xs = new List&lt;int[]&gt;() { new[] { 1, 2 }, new[] { 3, 4 } };
csharp> xs
{ { 1, 2 }, { 3, 4 } }
csharp> var ys = xs.GetRange(0, 2); // 0 番目から要素 2 つをコピー(浅いコピー)
csharp> ys
{ { 1, 2 }, { 3, 4 } }
csharp> ys[0][0] = 10
csharp> ys
{ { 10, 2 }, { 3, 4 } }
csharp> xs
{ { 10, 2 }, { 3, 4 } } // 浅いコピーなので要素は共有している
            </example>
        </method>

        <method name="GetType">
        </method>

        <method name="IndexOf">
            <sig>int (T item)</sig>
            <sig>int (T item, int startIndex)</sig>
            <sig>int (T item, int startIndex, int count)</sig>
            <desc>
                指定したオブジェクトを検索します。
                最初に見つかったオブジェクトのインデックスを返します。
                見つからなければ -1 を返します。

                引数 startIndex: 検索の開始位置インデックス
                引数 count: 検索する要素数
            </desc>
            <example>
csharp> var xs = new List&lt;int&gt;() { 1, 2, 3, 4, 5 };
csharp> xs.IndexOf(3);
2
csharp> xs.IndexOf(3, 3);
-1
csharp> xs.IndexOf(5, 0, 1);
-1
            </example>
        </method>

        <method name="Insert">
            <sig>void (int index, T item)</sig>
            <desc>
                指定したインデックスに要素を挿入します。
            </desc>
            <example>
csharp> var xs = new List&lt;int&gt;() { 1, 2, 3 };
csharp> xs.Insert(1, 100);
csharp> xs
{ 1, 100, 2, 3 }
            </example>
        </method>

        <method name="InsertRange">
            <sig>void (int index, IEnumerable&lt;T&gt; xs)</sig>
            <desc>指定したインデックスにシーケンス xs を挿入します。</desc>
            <example>
csharp> var xs = new List&lt;int&gt;() { 1, 2, 3 };
csharp> xs.InsertRange(0, new[] { 10, 20 });
csharp> xs
{ 10, 20, 1, 2, 3 }
csharp> xs.InsertRange(1, new[] { 55 });
csharp> xs
{ 10, 55, 20, 1, 2, 3 }
            </example>
        </method>

        <method name="LastIndexOf">
            <sig>int (T item)</sig>
            <sig>int (T item, int index)</sig>
            <sig>int (T item, int index, int count)</sig>
        </method>

        <method name="MemberwiseClone">
        </method>

        <method name="Remove">
            <sig>bool (T x)</sig>
            <desc>
                リストの最初に現れる x を取り除きます。
                x を取り除くことが出来た場合は true を返します。
            </desc>
            <example>
csharp> var xs = new List&lt;int&gt;() { 1, 2, 3, 2, 4, 2 };
csharp> xs
{ 1, 2, 3, 2, 4, 2 }
csharp> xs.Remove(2);
true
csharp> xs
{ 1, 3, 2, 4, 2 }
csharp> xs.Remove(2);
true
csharp> xs
{ 1, 3, 4, 2 }
csharp> xs.Remove(10);
false
csharp> xs
{ 1, 3, 4, 2 }
            </example>
        </method>

        <method name="RemoveAll">
            <sig>int (Predicate&lt;T&gt; pred)</sig>
            <desc>
                pred にマッチする要素をリストから全て取り除きます。
                削除した要素数を返します。
            </desc>
            <example>
csharp> var xs = Enumerable.Range(0, 10).ToList();
csharp> xs
{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }
csharp> xs.RemoveAll(e => e % 2 == 0);
5
csharp> xs
{ 1, 3, 5, 7, 9 }
csharp> xs.RemoveAll(e => e == 5);
1
csharp> xs
{ 1, 3, 7, 9 }
csharp> xs.RemoveAll(e => e == 123);
0
csharp> xs
{ 1, 3, 7, 9 }
            </example>
        </method>

        <method name="RemoveAt">
            <sig>void (int index)</sig>
            <desc>リストの index 番目の要素を削除します。</desc>
            <example>
csharp> var xs = new List&lt;int&gt;() { 1, 2, 3 };
csharp> xs.RemoveAt(0);
csharp> xs
{ 2, 3 }
csharp> xs.RemoveAt(1);
csharp> xs
{ 2 }
            </example>
        </method>

        <method name="RemoveRange">
            <sig>void (int index, int count)</sig>
            <desc>
                リストの index 番目から count 個の要素を削除します。
            </desc>
            <example>
csharp> var xs = new List&lt;int&gt;() { 1, 2, 3, 4, 5 };
csharp> xs.RemoveRange(1, 3);
csharp> xs
{ 1, 5 }
            </example>
        </method>

        <method name="Reverse">
            <sig>void ()</sig>
            <desc>リストを反転します。</desc>
            <example>
csharp> var xs = new List&lt;int&gt;() { 1, 2, 3};
csharp> xs.Reverse();
csharp> xs
{ 3, 2, 1 }
            </example>
        </method>

        <method name="Sort">
            <sig>void ()</sig>
            <sig>void (Comparison&lt;T&gt; comparison)</sig>
            <sig>void (IComparer&lt;T&gt; comparer)</sig>
            <sig>void (int index, int count, IComparer&lt;T&gt; comparer)</sig>
            <desc>
                ソートします。
            </desc>
            <example>
csharp> var xs = new List&lt;string&gt;() { "class", "string", "list" };
csharp> xs.Sort();
csharp> xs
{ "class", "list", "string" }
csharp> xs.Sort((a, b) => a.Length.CompareTo(b.Length));
csharp> xs
{ "list", "class", "string" }
csharp>
            </example>
        </method>

        <method name="ToArray">
            <sig>T[] ()</sig>
        </method>

        <method name="ToString">
            <sig>string ()</sig>
        </method>

        <method name="TrimExcess">
            <sig>void ()</sig>
        </method>

        <method name="TrueForAll">
            <sig>bool (Predicate&lt;T&gt; pred)</sig>
            <desc>
                リストの全ての要素が pred を満たすなら true を返します。
            </desc>
            <example>
csharp> var xs = new List&lt;int&gt;() { 2, 4, 6, 8, 10 };
csharp> xs.TrueForAll(e => e &lt;= 10);
true
csharp> xs.TrueForAll(e => e % 2 == 0);
true
csharp> xs.TrueForAll(e => e == 10);
false
            </example>
        </method>
    </class>

    <class name="String">
        <url>https://msdn.microsoft.com/ja-jp/library/system.string(v=vs.110).aspx</url>
        <namespace>System</namespace>

        <constructor>
            <sig>(char* value)</sig>
            <sig>(char* value, int startIndex, int length)</sig>
            <sig>(char c, int count)</sig>
            <sig>(char[] value)</sig>
            <sig>(char[] value, int startIndex, int length)</sig>
            <sig>(sbyte* value)</sig>
            <sig>(sbyte* value, int startIndex, int length)</sig>
            <sig>(sbyte* value, int startIndex, int length, Encoding enc)</sig>
        </constructor>

        <field name="Empty">
        </field>

        <property name="Chars">
            <desc>
                public char this[int index] { get; }
            </desc>
        </property>

        <property name="Length">
        </property>

        <method name="Clone">
        </method>

        <method name="Compare">
        </method>

        <method name="CompareTo">
        </method>

        <static-method name="Concat">
            <sig>string (object o)</sig>
            <sig>string (object o, object o2)</sig>
            <sig>string (object o, object o2, object o3)</sig>
            <sig>string (object o, object o2, object o3, object o4)</sig>
            <sig>string (object[] objs)</sig>
            <sig>string (string s)</sig>
            <sig>string (string s, string s2)</sig>
            <sig>string (string s, string s2, string s3)</sig>
            <sig>string (string s, string s2, string s3, string s4)</sig>
            <sig>string (string[] ss)</sig>
            <sig>string (IEnumerable&lt;T&gt; xs)</sig>
            <desc>
                指定したオブジェクトを文字列形式で連結します。
            </desc>
            <example>
csharp> string.Concat(1, "foo");
"1foo"
csharp> string.Concat(new[] { 1, 2, 3 });
"123"
            </example>
        </static-method>

        <method name="Contains">
            <sig>bool (string s)</sig>
            <desc>文字列に部分文字列 s が含まれるなら true を返します。</desc>
            <example>
csharp> var s = "foo bar baz";
csharp> s.Contains("bar");
true
csharp> s.Contains("foobar");
false
            </example>
        </method>

        <method name="Copy">
        </method>


        <method name="CopyTo">
        </method>

        <method name="EndsWith">
            <sig>bool (string value)</sig>
            <sig>bool (string value, StringComparison type)</sig>
            <sig>bool (string value, bool ignoreCase, CultureInfo culture)</sig>
        </method>

        <method name="Equals">
        </method>

        <static-method name="Format">
        </static-method>

        <method name="GetEnumerator">
        </method>

        <method name="GetHashCode">
        </method>

        <method name="GetType">
        </method>

        <method name="GetTypeCode">
        </method>

        <method name="IndexOf">
            <sig>int (char   value)</sig>
            <sig>int (string value)</sig>
            <sig>int (char   value, int startIndex)</sig>
            <sig>int (string value, int startIndex)</sig>
            <sig>int (string value, StringComparison type)</sig>
            <sig>int (char   value, int startIndex, int count)</sig>
            <sig>int (string value, int startIndex, int count)</sig>
            <sig>int (string value, int startIndex, StringComparison type)</sig>
            <sig>int (string value, int startIndex, int count, StringComparison type)</sig>
            <desc>
                文字、または文字列を検索する。最初に見つかったインデックスを返します。
                見つからなければ、-1 を返します。
            </desc>
            <example>
csharp> var s = "abcd-abcd";
csharp> s.IndexOf('-');
4
csharp> s.IndexOf("zz");
-1
csharp> s.IndexOf("a", 1); // インデックス 1 から検索する
5
csharp> s.IndexOf('a');
0
            </example>
        </method>

        <method name="IndexOfAny">
            <sig>int (char[] anyOf)</sig>
            <sig>int (char[] anyOf, int startIndex)</sig>
            <sig>int (char[] anyOf, int startIndex, int count)</sig>
            <desc>
                引数の文字配列のいずれかの文字を検索します。
                最初に見つかった文字のインデックスを返します。
                見つからなければ、-1 を返します。
            </desc>
            <example>
sharp> var s = "hello world";
csharp> s.IndexOfAny("or".ToCharArray());
4
csharp> s.IndexOfAny("ab".ToCharArray());
-1
            </example>
        </method>

        <method name="Insert">
            <sig>string (int startIndex, string value)</sig>
            <desc>
                startIndex に文字列 value を挿入した新しい文字列を返します。
                元の文字列は変更されません。
            </desc>
            <example>
csharp> var s = "hello world"
csharp> s.Insert(2, "abc");
"heabcllo world"
csharp> s
"hello world"
            </example>
        </method>

        <static-method name="Intern">
        </static-method>

        <static-method name="IsInterned">
        </static-method>

        <method name="IsNormalized">
        </method>

        <static-method name="IsNullOrEmpty">
        </static-method>

        <static-method name="IsNullOrWhiteSpace">
        </static-method>

        <static-method name="Join">
            <sig>string (string separator, IEnumerable&lt;string&gt; xs)</sig>
            <sig>string (string separator, params object[] xs)</sig>
            <sig>string (string separator, params string[] xs)</sig>
            <sig>string (string separator, string[] xs, int startIndex, int count)</sig>
            <sig>string (string separator, IEnumerable&lt;T&gt; xs)</sig>
        </static-method>

        <method name="LastIndexOf">
            <sig>int (char c)</sig>
            <sig>int (char c, int startIndex)</sig>
            <sig>int (char c, int startIndex, int count)</sig>
            <sig>int (string s)</sig>
            <sig>int (string s, int startIndex)</sig>
            <sig>int (string s, int startIndex, int count)</sig>
            <sig>int (string s, int startIndex, int count, StringComparison comparison)</sig>
            <sig>int (string s, int startIndex, StringComparison comparison)</sig>
            <sig>int (string s, StringComparison comparison)</sig>
            <desc>
                IndexOf() と同じだが、最後に見つかった文字、文字列のインデックスを返す。
                見つからなければ、-1 を返す。
            </desc>
        </method>

        <method name="LastIndexOfAny">
            <sig>int (char[] anyOf)</sig>
            <sig>int (char[] anyOf, int startIndex)</sig>
            <sig>int (char[] anyOf, int startIndex, int count)</sig>
            <desc>
                IndexOfAny() と同じだが、最後に見つかった文字、文字列のインデックスを返す。
                見つからなければ、-1 を返す。
            </desc>
        </method>

        <method name="Normalize">
        </method>

        <method name="PadLeft">
            <sig>string (int totalWidth)</sig>
            <sig>string (int totalWidth, char paddingChar)</sig>
            <example>
csharp> var s = "abc";
csharp> s.PadLeft(5);
"  abc"
csharp> s.PadLeft(5, '-');
"--abc"
            </example>
        </method>

        <method name="PadRight">
            <sig>string (int totalWidth)</sig>
            <sig>string (int totalWidth, char paddingChar)</sig>
            <example>
csharp> var s = "abc";
csharp> s.PadRight(5);
"abc  "
csharp> s.PadRight(5, '-');
"abc--"
            </example>
        </method>

        <method name="Remove">
            <sig>string (int startIndex)</sig>
            <sig>string (int startIndex, int count)</sig>
            <desc>
                startIndex 以降の文字列を取り除いた新しい文字列を返します。
            </desc>
            <example>
csharp> var s = "helloworld";
csharp> s.Remove(2);
"he"
csharp> s
"helloworld"
csharp> s.Remove(2, 3);
"heworld"
            </example>
        </method>

        <method name="Replace">
            <sig>string (char oldChar, char newChar)</sig>
            <sig>string (string oldValue, string newValue)</sig>
            <example>
csharp> "abcabc".Replace("abc", "def"); // 全ての文字列が置換される
"defdef"
csharp> "hello world".Replace('o', '-'); // 全ての文字が置換される
"hell- w-rld"
            </example>
        </method>

        <method name="Split">
        </method>

        <method name="StartsWith">
            <sig>bool (string value)</sig>
            <sig>bool (string value, StringComparison type)</sig>
            <sig>bool (string value, bool ignoreCase, CultureInfo culture)</sig>
        </method>

        <method name="Substring">
            <sig>string (int startIndex)</sig>
            <sig>string (int startIndex, int length)</sig>
            <example>
csharp> var s = "abc-def";
csharp> s.Substring(3);
"-def"
csharp> s.Substring(3, 2);
"-d"
            </example>
        </method>

        <method name="ToCharArray">
            <sig>char[] ()</sig>
            <sig>char[] (int startIndex, int length)</sig>
            <desc>
                文字の配列を返します。
            </desc>
            <example>
csharp> s.ToCharArray();
{ 'a', 'b', 'c', 'd', 'e' }
csharp> s.ToCharArray(1, 2);
{ 'b', 'c' }
            </example>

        </method>

        <method name="ToLower">
        </method>

        <method name="ToLowerInvariant">
        </method>

        <method name="ToString">
        </method>

        <method name="ToUpper">
        </method>

        <method name="ToUpperInvariant">
        </method>

        <method name="Trim">
            <sig>string ()</sig>
            <sig>string (params char[] trimChars)</sig>
            <desc>文字列の先頭と末尾の空白文字を取り除いた文字列を生成して返します。</desc>
            <example>
csharp> var s = "  abc  ";
csharp> s.Trim();
"abc"
csharp> s
"  abc  "
csharp> " \n\t foo \n".Trim();
"foo"
csharp> "-- foo --".Trim(new[] { '-' });
" foo "
            </example>
        </method>

        <method name="TrimEnd">
            <sig>string (params char[] trimChars)</sig>
            <desc>文字列の末尾の空白文字を取り除いた文字列を生成して返します。</desc>
            <example>
csharp> var s = "  foo  ";
csharp> s.TrimEnd();
"  foo"
csharp> s
"  foo  "
csharp> "-- foo --".TrimEnd(new[] { '-' });
"-- foo "
            </example>
        </method>

        <method name="TrimStart">
            <sig>string (params char[] trimChars)</sig>
            <desc>文字列の先頭の空白文字を取り除いた文字列を生成して返します。</desc>
            <example>
csharp> var s = "  foo  ";
csharp> s.TrimStart();
"foo  "
csharp> s
"  foo  "
csharp> "-- foo --".TrimStart(new[] { '-' });
" foo --"
            </example>
        </method>

    </class>

    <class name="Array">
        <url>https://msdn.microsoft.com/ja-jp/library/system.array(v=vs.110).aspx</url>
        <namespace>System</namespace>

        <static-method name="AsReadOnly">
            <sig>ReadOnlyCollection&lt;T&gt; &lt;T&gt;(T[] ar)</sig>
        </static-method>

        <static-method name="BinarySearch">
            <sig>int (Array ar, int index, int length, object value)</sig>
            <sig>int (Array ar, int index, int length, object value, IComparer comparer)</sig>
            <sig>int (Array ar, object value)</sig>
            <sig>int (Array ar, object value, IComparer comparer)</sig>
            <sig>int &lt;T&gt;(T[] ar, T value)</sig>
            <sig>int &lt;T&gt;(T[] ar, T value, IComparer&lt;T&gt; comparer)</sig>
            <sig>int &lt;T&gt;(T[] ar, int index, int length, T value)</sig>
            <sig>int &lt;T&gt;(T[] ar, int index, int length, T value, IComparer&lt;T&gt; comparer)</sig>
        </static-method>

        <static-method name="Clear">
            <sig>void (Array ar, int index, int length)</sig>
            <desc>配列の指定範囲に型の既定値を格納します。</desc>
            <example>
csharp> var xs = new[] { 1, 2, 3 };
csharp> Array.Clear(xs, 0, xs.Length);
csharp> xs
{ 0, 0, 0 }
csharp> var ys = new[] { 1, 2, 3, 4, 5 };
csharp> Array.Clear(ys, 2, 1);
csharp> ys
{ 1, 2, 0, 4, 5 }
            </example>
        </static-method>

        <static-method name="Clone">
            <sig>object ()</sig>
        </static-method>

        <static-method name="ConstrainedCopy">
            <sig>void (Array src, int srcIndex, Array dst, int dstIndex, int length)</sig>
        </static-method>

        <static-method name="ConvertAll">
            <sig>TOutput[] &lt;TInput, TOutput&gt;(TInput[] ar, Converter&lt;TInput, TOutput&gt; converter)</sig>
        </static-method>

		<static-method name="Copy">
			<sig>void (Array src, Array dst, int length)</sig>
			<sig>void (Array src, Array dst, long length)</sig>
			<sig>void (Array src, int srcIndex, Array dst, int dstIndex, int length)</sig>
			<sig>void (Array src, long srcIndex, Array dst, long dstIndex, long length)</sig>
			<desc>
				配列をコピーします。
			</desc>
			<example>
csharp> var xs = new int[] { 1, 23, 456 };
csharp> var ys = new int[xs.Length];
csharp> ys
{ 0, 0, 0 }
csharp> Array.Copy(xs, ys, xs.Length); // xs を ys へコピーする
csharp> ys
{ 1, 23, 456 }
csharp> Array.Copy(xs, 1, ys, 0, 2); //  xs の 1 番目から、ys の 0 番目へ
                                     //  要素 2 つ分コピーする
csharp> ys
{ 23, 456, 456 }
			</example>

        </static-method>

		<method name="CopyTo">
			<sig>void (Array dst, int dstStartIndex)</sig>
			<sig>void (Array dst, long dstStartIndex)</sig>
			<desc>
				配列をコピーします。
				引数には、コピー先の配列と、コピー先のコピー開始位置を指定します。
				コピー先の要素数が足りない場合は、System.ArgumentException が生成されます。
			</desc>
			<example>
csharp> var xs = new int[] { 1, 23, 456 };
csharp> var ys = new int[xs.Length];
csharp> ys
{ 0, 0, 0 }
csharp> xs.CopyTo(ys, 0); // xs を ys の 0 番目からコピーする

csharp> var zs = new int[xs.Length + 1];
csharp> zs
{ 0, 0, 0, 0 }
csharp> xs.CopyTo(zs, 1); // xs を zs の 1 番目からコピーする
csharp> zs
{ 0, 1, 23, 456 }
csharp> xs.CopyTo(zs, 2); // System.ArgumentException が発生する(要素数が足りないため)。
			</example>


        </method>

        <static-method name="CreateInstance">
            <sig>Array (Type elementType, int length)</sig>
            <sig>Array (Type elementType, int length1, int length2)</sig>
            <sig>Array (Type elementType, int length1, int length2, int length3)</sig>
            <sig>Array (Type elementType, params int[] lengths)</sig>
            <sig>Array (Type elementType, int[] lengths, int[] lowerBounds)</sig>
            <sig>Array (Type elementType, params long[] lengths)</sig>
        </static-method>

        <static-method name="Empty">
            <sig>T[] &lt;T&gt;()</sig>
        </static-method>

        <static-method name="Equals">
        </static-method>

        <static-method name="Exists">
            <sig>bool &lt;T&gt;(T[] ar, Predicate&lt;T&gt; pred)</sig>
        </static-method>

        <static-method name="Finalize">
        </static-method>

        <static-method name="Find">
            <sig>T &lt;T&gt;(T[] ar, Predicate&lt;T&gt; pred)</sig>
        </static-method>

        <static-method name="FindAll">
            <sig>T[] &lt;T&gt;(T[] ar, Predicate&lt;T&gt; pred)</sig>
        </static-method>

        <static-method name="FindIndex">
            <sig>int &lt;T&gt;(T[] ar, int startIndex, int count, Predicate&lt;T&gt; pred)</sig>
            <sig>int &lt;T&gt;(T[] ar, int startIndex, Predicate&lt;T&gt; pred)</sig>
            <sig>int &lt;T&gt;(T[] ar, Predicate&lt;T&gt; pred)</sig>
        </static-method>

        <static-method name="FindLast">
            <sig>T &lt;T&gt;(T[] ar, Predicate&lt;T&gt; pred)</sig>
        </static-method>

        <static-method name="FindLastIndex">
            <sig>int &lt;T&gt;(T[] ar, int startIndex, int count, Predicate&lt;T&gt; pred)</sig>
            <sig>int &lt;T&gt;(T[] ar, int startIndex, Predicate&lt;T&gt; pred)</sig>
            <sig>int &lt;T&gt;(T[] ar, Predicate&lt;T&gt; pred)</sig>
        </static-method>

        <static-method name="ForEach">
            <sig>void &lt;T&gt;(T[] ar, Action&lt;T&gt; action)</sig>
        </static-method>

        <method name="GetEnumerator">
            <sig>IEnumerator ()</sig>
        </method>

        <method name="GetHashCode">
        </method>

        <method name="GetLength">
            <sig>int (int dimension)</sig>
        </method>

        <method name="GetLongLength">
            <sig>long (int dimension)</sig>
        </method>

        <method name="GetLowerBound">
            <sig>int (int dimension)</sig>
        </method>

        <method name="GetType">
        </method>

        <method name="GetUpperBound">
            <sig>int (int dimension)</sig>
        </method>

        <method name="GetValue">
            <sig>object (int index)</sig>
            <sig>object (int index1, int index2)</sig>
            <sig>object (int index1, int index2, int index3)</sig>
            <sig>object (params int[] indices)</sig>
            <sig>object (long index)</sig>
            <sig>object (long index1, long index2)</sig>
            <sig>object (long index1, long index2, long index3)</sig>
            <sig>object (params long[] indices)</sig>
        </method>

        <static-method name="IndexOf">
            <sig>int (Array ar, object value)</sig>
            <sig>int (Array ar, object value, int startIndex)</sig>
            <sig>int (Array ar, object value, int startIndex, int count)</sig>
            <sig>int &lt;T&gt;(T[] ar, T value)</sig>
            <sig>int &lt;T&gt;(T[] ar, T value, int startIndex)</sig>
            <sig>int &lt;T&gt;(T[] ar, T value, int startIndex, int count)</sig>
        </static-method>

        <method name="Initialize">
            <sig>void ()</sig>
        </method>

        <static-method name="LastIndexOf">
            <sig>int (Array ar, object value)</sig>
            <sig>int (Array ar, object value, int startIndex)</sig>
            <sig>int (Array ar, object value, int startIndex, int count)</sig>
            <sig>int &lt;T&gt;(T[] ar, T value)</sig>
            <sig>int &lt;T&gt;(T[] ar, T value, int startIndex)</sig>
            <sig>int &lt;T&gt;(T[] ar, T value, int startIndex, int count)</sig>
        </static-method>

        <method name="MemberwiseClone">
        </method>

        <static-method name="Resize">
            <sig>void &lt;T&gt;(ref T[] ar, int newSize)</sig>
            <desc>1 次元配列のサイズを newSize に変更します。</desc>
            <example>
csharp> var xs = new[] { 1, 2, 3 };
csharp> Array.Resize(ref xs, 5);
csharp> xs
{ 1, 2, 3, 0, 0 }
csharp> Array.Resize(ref xs, 2);
csharp> xs
{ 1, 2 }
csharp> int[] ys = null;
csharp> Array.Resize(ref ys, 3);
csharp> ys
{ 0, 0, 0 }
            </example>
        </static-method>

        <static-method name="Reverse">
            <sig>void (Array ar)</sig>
            <sig>void (Array ar, int index, int length)</sig>
            <desc>配列を反転します。</desc>
            <example>
csharp> var xs = new[] { 1, 2, 3 };
csharp> xs
{ 1, 2, 3 }
csharp> Array.Reverse(xs);
csharp> xs
{ 3, 2, 1 }
csharp> var ys = new[] { 1, 2, 3, 4, 5, 6 };
csharp> Array.Reverse(ys, 1, 3); // 1 番目から 3 個
csharp> ys
{ 1, 4, 3, 2, 5, 6 }
            </example>
        </static-method>

        <method name="SetValue">
            <sig>void (object value, int index)</sig>
            <sig>void (object value, int index1, int index2)</sig>
            <sig>void (object value, int index1, int index2, int index3)</sig>
            <sig>void (object value, params int[] indices)</sig>
            <sig>void (object value, long index)</sig>
            <sig>void (object value, long index1, long index2)</sig>
            <sig>void (object value, long index1, long index2, long index3)</sig>
            <sig>void (object value, params long[] indices)</sig>
        </method>

        <static-method name="Sort">
            <sig>void (Array ar)</sig>
            <sig>void (Array keys, Array items)</sig>
            <sig>void (Array keys, Array items, IComparer comparer)</sig>
            <sig>void (Array keys, Array items, int index, int length)</sig>
            <sig>void (Array keys, Array items, int index, int length, IComparer comparer)</sig>
            <sig>void (Array ar, IComparer comparer)</sig>
            <sig>void (Array ar, int index, int length)</sig>
            <sig>void (Array ar, int index, int length, IComparer comparer)</sig>
            <sig>void &lt;T&gt;(T[] ar)</sig>
            <sig>void &lt;T&gt;(T[] ar, Comparison&lt;T&gt; comparison)</sig>
            <sig>void &lt;T&gt;(T[] ar, IComparer&lt;T&gt; comparer)</sig>
            <sig>void &lt;T&gt;(T[] ar, int index, int length)</sig>
            <sig>void &lt;T&gt;(T[] ar, int index, int length, IComparer&lt;T&gt; comparer)</sig>
            <sig>void &lt;TKey, TValue&gt;(TKey[] keys, TValue[] items)</sig>
            <sig>void &lt;TKey, TValue&gt;(TKey[] keys, TValue[] items, IComparer&lt;TKey&gt; comparer</sig>
            <sig>void &lt;TKey, TValue&gt;(TKey[] keys, TValue[] items, int index, int length)</sig>
            <sig>void &lt;TKey, TValue&gt;(TKey[] keys, TValue[] items, int index, int length, IComparer&lt;TKey&gt; comparer)</sig>
        </static-method>

        <method name="ToString">
        </method>

        <static-method name="TrueForAll">
            <sig>bool &lt;T&gt;(T[] ar, Predicate&lt;T&gt; pred)</sig>
        </static-method>
    </class>

    <class name="Dictionary&lt;TKey, TValue&gt;">
        <url>https://msdn.microsoft.com/ja-jp/library/xfhwa508(v=vs.110).aspx</url>
        <namespace>System.Collections.Generic</namespace>

        <constructor>
            <sig>()</sig>
            <sig>(IDictionary&lt;TKey, TValue&gt; dict)</sig>
            <sig>(IDictionary&lt;TKey, TValue&gt; dict, IEqualityComparer&lt;TKey&gt; comparer)</sig>
            <sig>(IEqualityComparer&lt;TKey&gt; comparer)</sig>
            <sig>(int capacity)</sig>
            <sig>(int capacity, IEqualityComparer&lt;TKey&gt; comparer)</sig>
            <sig>(SerializationInfo info, StreamingContext context)</sig>
        </constructor>

        <method name="Add">
            <sig>void (TKey key, TValue value)</sig>
        </method>

        <method name="Clear">
            <sig>void ()</sig>
        </method>

        <method name="ContainsKey">
            <sig>bool (TKey key)</sig>
        </method>

        <method name="ContainsValue">
            <sig>bool (TValue value)</sig>
        </method>

        <method name="Equals">
        </method>

        <method name="Finalize">
        </method>

        <method name="GetEnumerator">
            <sig>Dictionary&lt;TKey, TValue&gt;.Enumerator ()</sig>
        </method>

        <method name="GetHashCode">
        </method>

        <method name="GetObjectData">
            <sig>void (SerializationInfo info, StreamingContext context)</sig>
        </method>

        <method name="GetType">
        </method>

        <method name="MemberwiseClone">
        </method>

        <method name="OnDeserialization">
            <sig>void (object sender)</sig>
        </method>

        <method name="Remove">
            <sig>bool (TKey key)</sig>
        </method>

        <method name="ToString">
            <sig>string ()</sig>
        </method>

        <method name="TryGetValue">
            <sig>bool (TKey key, out TValue value)</sig>
        </method>

        <property name="Comparer">
        </property>

        <property name="Count">
        </property>

        <property name="Item">
        </property>

        <property name="Keys">
        </property>

        <property name="Values">
        </property>

    </class>

    <class name="HashSet&lt;T&gt;">
        <url>https://msdn.microsoft.com/ja-jp/library/bb359438(v=vs.110).aspx</url>
        <namespace>System.Collections.Generic</namespace>

        <constructor>
            <sig>()</sig>
            <sig>(IEnumerable&lt;T&gt; xs)</sig>
            <sig>(IEnumerable&lt;T&gt; xs, IEqualityComparer&lt;T&gt; comparer)</sig>
            <sig>(IEqualityComparer&lt;T&gt; comparer)</sig>
            <sig>(SerializationInfo info, StreamingContext context)</sig>
        </constructor>

        <method name="Add">
            <sig>bool (T item)</sig>
        </method>

        <method name="Clear">
            <sig>void ()</sig>
        </method>

        <method name="Contains">
            <sig>bool (T item)</sig>
        </method>

        <method name="CopyTo">
            <sig>void (T[] dst)</sig>
            <sig>void (T[] dst, int dstIndex)</sig>
            <sig>void (T[] dst, int dstIndex, int count)</sig>
        </method>

        <static-method name="CreateSetComparer">
            <sig>IEqualityComparer&lt;HashSet&lt;T&gt;&gt; ()</sig>
        </static-method>

        <method name="Equals">
        </method>

        <method name="ExceptWith">
            <sig>void (IEnumerable&lt;T&gt; other)</sig>
        </method>

        <method name="Finalize">
        </method>

        <method name="GetEnumerator">
            <sig>HashSet&lt;T&gt;.Enumerator ()</sig>
        </method>

        <method name="GetHashCode">
        </method>

        <method name="GetObjectData">
            <sig>void (SerializationInfo info, StreamingContext context)</sig>
        </method>

        <method name="GetType">
        </method>

        <method name="IntersectWith">
            <sig>void (IEnumerable&lt;T&gt; other)</sig>
        </method>

        <method name="IsProperSubsetOf">
            <sig>bool (IEnumerable&lt;T&gt; other)</sig>
        </method>

        <method name="IsProperSupersetOf">
            <sig>bool (IEnumerable&lt;T&gt; other)</sig>
        </method>

        <method name="IsSubsetOf">
            <sig>bool (IEnumerable&lt;T&gt; other)</sig>
        </method>

        <method name="IsSupersetOf">
            <sig>bool (IEnumerable&lt;T&gt; other)</sig>
        </method>

        <method name="MemberwiseClone">
        </method>

        <method name="OnDeserialization">
            <sig>void (object sender)</sig>
        </method>

        <method name="Overlaps">
            <sig>bool (IEnumerable&lt;T&gt; other)</sig>
        </method>

        <method name="Remove">
            <sig>bool (T item)</sig>
        </method>

        <method name="RemoveWhere">
            <sig>int (Predicate&lt;T&gt; pred)</sig>
        </method>

		<method name="SetEquals">
			<sig>bool (IEnumerable&lt;T&gt; other)</sig>
			<desc>other の要素と一致するなら true を返します。</desc>
			<example>
csharp> var hs = new HashSet&lt;int&gt;() { 1, 2, 3 };
csharp> hs.SetEquals(hs);
true
csharp> hs.SetEquals(new[] { 2, 3, 1 });
true
csharp> hs.SetEquals(new[] { 2, 3 });
false
csharp> hs.SetEquals(new[] { 2, 3, 1, 4 });
false
			</example>
        </method>

        <method name="SymmetricExceptWith">
            <sig>void (IEnumerable&lt;T&gt; other)</sig>
        </method>

        <method name="ToString">
        </method>

        <method name="TrimExcess">
            <sig>void ()</sig>
        </method>

        <method name="UnionWith">
            <sig>void (IEnumerable&lt;T&gt; other)</sig>
        </method>

        <property name="Comparer">
        </property>

        <property name="Count">
        </property>

    </class>


    <class name="Stack&lt;T&gt;">
        <url>https://msdn.microsoft.com/ja-jp/library/3278tedw(v=vs.110).aspx</url>
        <namespace>System.Collections.Generic</namespace>

        <constructor>
            <sig>()</sig>
            <sig>(IEnumerable&lt;T&gt; xs)</sig>
            <sig>(int capacity)</sig>
        </constructor>

        <method name="Clear">
            <sig>void ()</sig>
            <desc>スタックを空にします。</desc>
            <example>
csharp> var s = new Stack&lt;int&gt;(new[] { 1, 2, 3 });
csharp> s
{ 3, 2, 1 }
csharp> s.Clear();
csharp> s
{  }
            </example>
        </method>

        <method name="Contains">
            <sig>bool (T item)</sig>
            <desc>スタックに要素が存在するなら true を返します。</desc>
            <example>
csharp> var s = new Stack&lt;int&gt;();
csharp> s.Contains(10);
false
csharp> s.Push(10);
csharp> s.Contains(10);
true
            </example>
        </method>

        <method name="CopyTo">
            <sig>void (T[] ary, int aryIndex)</sig>
            <desc>
                スタックの要素を引数 ary にコピーします。

                引数 aryIndex: ary のコピー先開始位置
            </desc>
            <example>
csharp> var s = new Stack&lt;int&gt;(new[] { 1, 2, 3 });
csharp> s.CopyTo(xs, 0); // コピー先は 0 番目から。
csharp> xs
{ 3, 2, 1, 0, 0, 0 }
csharp> s.CopyTo(xs, 2); // コピー先は 2 番目から。
csharp> xs
{ 3, 2, 3, 2, 1, 0 }
            </example>
        </method>

        <method name="Equals">
        </method>

        <method name="Finalize">
        </method>

        <method name="GetEnumerator">
            <sig>Stack&lt;T&gt;.Enumerator ()</sig>
        </method>

        <method name="GetHashCode">
        </method>

        <method name="GetType">
        </method>

        <method name="MemberwiseClone">
        </method>

        <method name="Peek">
            <sig>T Peek()</sig>
            <desc>
                スタックのトップのオブジェクトを返します。
                オブジェクトはスタックから削除されません。
            </desc>
            <example>
csharp> var s = new Stack&lt;int&gt;(new[] { 1, 2, 3 });
csharp> s
{ 3, 2, 1 }
csharp> s.Peek();
3
csharp> s
{ 3, 2, 1 }
            </example>
        </method>

        <method name="Pop">
            <sig>T Pop()</sig>
            <desc>スタックからトップのオブジェクトを削除して返します。</desc>
            <example>
csharp> var s = new Stack&lt;int&gt;(new[] { 1, 2, 3});
csharp> s
{ 3, 2, 1 }
csharp> s.Pop();
3
csharp> s
{ 2, 1 }
csharp> s.Pop();
2
            </example>

        </method>

        <method name="Push">
            <sig>void (T item)</sig>
            <desc>スタックにオブジェクトを追加します。</desc>
            <example>
csharp> var s = new Stack&lt;in&gt;>();
csharp> s
{  }
csharp> s.Push(1);
csharp> s
{ 1 }
csharp> s.Push(2);
csharp> s
{ 2, 1 }
            </example>
        </method>

        <method name="ToArray">
            <sig>T[] ()</sig>
        </method>

        <method name="ToString">
            <sig>string ()</sig>
        </method>

        <method name="TrimExcess">
            <sig>void ()</sig>
        </method>

        <property name="Count">
        </property>
    </class>

    <class name="Queue&lt;T&gt;">
        <url>https://msdn.microsoft.com/ja-jp/library/7977ey2c(v=vs.110).aspx</url>
        <namespace>System.Collections.Generic</namespace>

        <constructor>
            <sig>()</sig>
            <sig>(IEnumerable&lt;T&gt; xs)</sig>
            <sig>(int capacity)</sig>
        </constructor>

        <method name="Clear">
            <sig>void ()</sig>
        </method>

        <method name="Contains">
            <sig>bool (T item)</sig>
        </method>

        <method name="CopyTo">
            <sig>void (T[] dst, int dstIndex)</sig>
        </method>

        <method name="Dequeue">
            <sig>T ()</sig>
        </method>

        <method name="Enqueue">
            <sig>void (T item)</sig>
        </method>

        <method name="Equals">
        </method>

        <method name="Finalize">
        </method>

        <method name="GetEnumerator">
            <sig>Queue&lt;T&gt;.Enumerator ()</sig>
        </method>

        <method name="GetHashCode">
        </method>

        <method name="GetType">
        </method>

        <method name="MemberwiseClone">
        </method>

        <method name="Peek">
            <sig>T ()</sig>
        </method>

        <method name="ToArray">
            <sig>T[] ()</sig>
        </method>

        <method name="ToString">
        </method>

        <method name="TrimExcess">
            <sig>void ()</sig>
        </method>

        <property name="Count">
        </property>
    </class>

    <class name="Random">
        <url>https://msdn.microsoft.com/ja-jp/library/system.random(v=vs.110).aspx</url>
        <namespace>System</namespace>

        <constructor>
            <sig>()</sig>
            <sig>(int seed)</sig>
        </constructor>

        <method name="Equals">
        </method>

        <method name="Finalize">
        </method>

        <method name="GetHashCode">
        </method>

        <method name="GetType">
        </method>

        <method name="MemberwiseClone">
        </method>

        <method name="Next">
            <sig>int ()</sig>
            <sig>int (int maxValue)</sig>
            <sig>int (int minValue, int maxValue)</sig>
            <desc>
                引数なしの場合は、0 以上、int.MaxValue 未満の int を返します。
                引数一つの場合は、0 以上、maxValue 未満の int を返します。
                引数二つの場合は、minValue 以上、maxValue 未満の int を返します。
            </desc>
        </method>

        <method name="NextBytes">
            <sig>void (byte[] buffer)</sig>
            <desc>
                引数 buffer にランダムなバイトを格納します。
            </desc>
        </method>

        <method name="NextDouble">
            <sig>double ()</sig>
            <desc>
                0.0 以上、1.0 未満の double を返します。
            </desc>
        </method>

        <method name="Sample">
            <sig>double ()</sig>
            <desc>
                0.0 以上、1.0 未満の double を返します。

                (このメソッドは protected です。代わりに NextDouble メソッドを使用します)
            </desc>
        </method>

        <method name="ToString">
        </method>

    </class>

    <class name="Enumerable">
        <url>https://msdn.microsoft.com/ja-jp/library/system.linq.enumerable_methods(v=vs.110).aspx</url>
        <namespace>System.Linq</namespace>

        <static-method name="Aggregate">
            <sig>T (this IEnumerable&lt;T&gt; xs, Func&lt;T, T, T&gt; fn)</sig>
            <sig>U (this IEnumerable&lt;T&gt; xs, U seed, Func&lt;U, T, U&gt; fn)</sig>
            <sig>R (this IEnumerable&lt;T&gt; xs, U seed, Func&lt;U, T, U&gt; fn, Func&lt;U, R&gt; retFn)</sig>
            <desc>シーケンスの畳み込みを行います。</desc>
            <example>
csharp> var xs = new[] { 1, 2, 3, 4, 5 };
csharp> xs.Aggregate((acc, e) => acc + e); // 和
15
csharp> xs.Aggregate((acc, e) => acc * e); // 積
120
csharp> xs.Aggregate((acc, e) => acc + e*e); // 二乗の和
55
csharp> xs.Aggregate(0, (acc, e) => acc + (e % 2 == 1 ? 1 : 0)); // 奇数の個数
3
            </example>
        </static-method>

        <static-method name="All">
            <sig>bool (this IEnumerable&lt;T&gt; xs, Func&lt;T, bool&gt; pred)</sig>
            <desc>
                全ての要素が pred を満たすかどうか調べます。
            </desc>
            <example>
csharp> var xs = new[] { 1, 2, 3, 4, 5 };
csharp> xs.All(e => e > 0); // 全ての要素は、0 より大きいか
true
csharp> xs.All(e => e % 2 == 0); // 全ての要素は、偶数か
false
            </example>

        </static-method>

        <static-method name="Any">
            <sig>bool ()</sig>
            <sig>bool (this IEnumerable&lt;T&gt; xs, Func&lt;T, bool&gt; pred)</sig>
            <desc>
                シーケンスに要素が含まれるか調べます。

                引数 pred: pred を満たす要素が含まれるか調べます。
            </desc>
            <example>
csharp> new[] { false }.Any();
true
csharp> new int[0].Any();
false
csharp> new[] { 1, 3, 5 }.Any(e => e % 2 == 0);
false
csharp> new[] { 1, 3, 5 }.Any(e => e == 3);
true
            </example>
        </static-method>

        <static-method name="AsEnumerable">
        </static-method>

        <static-method name="Average">
        </static-method>

        <static-method name="Cast">
        </static-method>

        <static-method name="Concat">
            <sig>IEnumerable&lt;T&gt; &lt;T&gt;(this IEnumerable&lt;T&gt; xs, IEnumerable&lt;T&gt; ys)</sig>
            <desc>シーケンスを連結します。</desc>
            <example>
csharp> var xs = new[] { 1, 2, 3 };
csharp> var ys = new[] { 4, 5 };
csharp> xs.Concat(ys);
{ 1, 2, 3, 4, 5 }
            </example>
        </static-method>

        <static-method name="Contains">
            <sig>bool (IEnumerable&lt;T&gt; xs, T val)</sig>
            <sig>bool (IEnumerable&lt;T&gt; xs, T val, IEqualityComparer&lt;T&gt; comparer)</sig>
            <desc>
                指定した要素がシーケンスに含まれるか判定します。
            </desc>
            <example>
csharp> var xs = new[] { 1, 3, 5, 7 };
csharp> xs.Contains(2);
false
csharp> xs.Contains(5);
true
            </example>

        </static-method>

		<static-method name="Count">
			<sig>int (this IEnumerable&lt;T&gt; xs)</sig>
			<sig>int (this IEnumerable&lt;T&gt; xs, Func&lt;T, bool&gt; pred</sig>
			<desc>要素数を返します。</desc>
			<example>
csharp> var xs = new List&lt;int&gt;() { -9, 9, 34, 9 }
csharp> xs.Count();
4
csharp> xs.Count(e => e == 9);
2
			</example>
        </static-method>

        <static-method name="DefaultIfEmpty">
            <sig>IEnumerable&lt;T&gt; (IEnumerable&lt;T&gt; xs)</sig>
            <sig>IEnumerable&lt;T&gt; (IEnumerable&lt;T&gt; xs, T defaultValue)</sig>
            <desc>
                シーケンスが空ならば、T の規定値をひとつ含むシーケンスを返します。
                シーケンスが空でなければ、シーケンスをそのまま返します。

                引数 defaultValue: シーケンスが空の場合の規定値
            </desc>
            <example>
csharp> var xs = new List&lt;int&gt;();
csharp> xs.DefaultIfEmpty();
{ 0 }
csharp> xs.DefaultIfEmpty(123);
{ 123 }
csharp> new[] { 10, 20 }.DefaultIfEmpty();
{ 10, 20 }
            </example>
        </static-method>

        <static-method name="Distinct">
            <sig>IEnumerable&lt;T&gt; (this IEnumerable&lt;T&gt; xs)</sig>
            <sig>IEnumerable&lt;T&gt; (this IEnumerable&lt;T&gt; xs, IEqualityComparer&lt;T&gt; comparer)</sig>
            <desc>
                シーケンスから重複を除いたシーケンスを返します。
            </desc>
            <example>
csharp> var xs = new[] { 1, 2, 2, 3, 3, 3, 100, 1, 1, 2, 34 };
csharp> xs.Distinct();
{ 1, 2, 3, 100, 34 }
            </example>
        </static-method>

        <static-method name="ElementAt">
            <sig>T (this IEnumerable&lt;T&gt; xs, int index)</sig>
            <desc>指定されたインデックスの要素を返します。</desc>
            <example>
csharp> var xs = new[] { 1, 2, 3 };
csharp> xs.ElementAt(0);
1
csharp> xs.ElementAt(1);
2
            </example>
        </static-method>

        <static-method name="ElementAtOrDefault">
            <sig>T (this IEnumerable&lt;T&gt; xs, int index)</sig>
            <desc>
                index 番目の要素を返します。
                index が範囲外のときは、デフォルトの値を返します。
            </desc>
            <example>
csharp> var xs = new[] { 10, 20, 30 };
csharp> xs.ElementAtOrDefault(0);
10
csharp> xs.ElementAtOrDefault(5);
0
            </example>
        </static-method>

        <static-method name="Empty">
            <sig>IEnumerable&lt;T&gt; &lt;T&gt;()</sig>
            <desc>IEnumerable&lt;T&gt; 型の空シーケンスを返します。</desc>
            <example>
csharp> Enumerable.Empty&lt;int&gt;();
{  }
            </example>
        </static-method>

        <static-method name="Except">
            <sig>IEnumerable&lt;T&gt; (this IEnumerable&lt;T&gt; xs, IEnumerable&lt;T&gt; ys)</sig>
            <sig>IEnumerable&lt;T&gt; (this IEnumerable&lt;T&gt; xs, IEnumerable&lt;T&gt; ys, IEqualityComparer&lt;T&gt; comparer)</sig>
            <desc>二つのシーケンスの差集合を返します。</desc>
            <example>
csharp> var xs = new[] { 1, 2, 2, 3, 3, 4 };
csharp> var ys = new[] { 2, 4, 5, 5 };
csharp> xs.Except(ys);
{ 1, 3 }
            </example>
        </static-method>

        <static-method name="First">
            <sig>T (this IEnumerable&lt;T&gt; xs)</sig>
            <sig>T (this IEnumerable&lt;T&gt; xs, Func&lt;T, bool&gt; pred)</sig>
            <desc>
                最初の要素を返します。
                シーケンスが空だったり、pred にマッチする要素が見つからない場合は、
                InvalidOperationException 例外が生成されます。
            </desc>
            <example>
csharp> var xs = new[] { 1, 2, 3, 4, 5 };
csharp> xs.First();
1
csharp> xs.First(e => e >= 3);
3
            </example>
        </static-method>

        <static-method name="FirstOrDefault">
            <sig>T (this IEnumerable&lt;T&gt; xs)</sig>
            <sig>T (this IEnumerable&lt;T&gt; xs, Func&lt;T, bool&gt; pred)</sig>
            <desc>
                最初の要素を返します。
                シーケンスが空だったり、pred にマッチする要素が見つからない場合は、
                規定値を返します。
                規定値を指定するには、DefaultIfEmpty() を使います。
            </desc>
            <example>
csharp> var xs = new int[0];
csharp> xs.FirstOrDefault();
0
csharp> new[] { 1, 2, 3 }.FirstOrDefault(e => e > 100);
0
csharp> xs.DefaultIfEmpty(100).First();
100
            </example>
        </static-method>

        <static-method name="GroupBy">
        </static-method>

        <static-method name="GroupJoin">
        </static-method>

        <static-method name="Intersect">
            <sig>IEnumerable&lt;T&gt; (this IEnumerable&lt;T&gt; xs, IEnumerable&lt;T&gt; ys)</sig>
            <sig>IEnumerable&lt;T&gt; (this IEnumerable&lt;T&gt; xs, IEnumerable&lt;T&gt; ys, IEqualityComparer&lt;T&gt; comparer)</sig>
            <desc>
                二つのシーケンスの積集合を返します。
            </desc>
            <example>
csharp> var xs = new[] { 1, 2, 2, 3 };
csharp> var ys = new[] { 2, 2, 3, 10, 10, 20 };
csharp> xs.Intersect(ys);
{ 2, 3 }
            </example>
        </static-method>

        <static-method name="Join">
        </static-method>

        <static-method name="Last">
            <sig>T (this IEnumerable&lt;T&gt; xs)</sig>
            <sig>T (this IEnumerable&lt;T&gt; xs, Func&lt;T, bool&gt; pred)</sig>
            <desc>
                最後の要素を返します。
                シーケンスが空だったり、pred にマッチする要素が見つからない場合は、
                InvalidOperationException 例外が生成されます。
            </desc>
            <example>
csharp> var xs = new[] { 1, 2, 3, 4, 5 };
csharp> xs.Last();
5
csharp> xs.Last(e => e &lt;= 3);
3
            </example>

        </static-method>

        <static-method name="LastOrDefault">
            <sig>T (this IEnumerable&lt;T&gt; xs)</sig>
            <sig>T (this IEnumerable&lt;T&gt; xs, Func&lt;T, bool&gt; pred)</sig>
            <desc>
                最後の要素を返します。
                シーケンスが空だったり、pred にマッチする要素が見つからない場合は、
                規定値を返します。
                規定値を指定するには、DefaultIfEmpty() を使います。
            </desc>
            <example>
csharp> var xs = new int[0];
csharp> xs.LastOrDefault();
0
csharp> new[] { 1, 2, 3 }.LastOrDefault(e => e > 100);
0
csharp> xs.DefaultIfEmpty(100).Last();
100
            </example>
        </static-method>

        <static-method name="LongCount">
        </static-method>

        <static-method name="Max">
        </static-method>

        <static-method name="Min">
        </static-method>

        <static-method name="OfType">
        </static-method>

        <static-method name="OrderBy">
        </static-method>

        <static-method name="OrderByDescending">
        </static-method>

        <static-method name="Range">
            <sig>IEnumerable&lt;T&gt; (int start, int count)</sig>
            <desc>
                指定された範囲のシーケンスを生成します。
            </desc>
            <example>
csharp> Enumerable.Range(0, 10);
{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }
csharp> Enumerable.Range(-5, 5);
{ -5, -4, -3, -2, -1 }
            </example>
        </static-method>

        <static-method name="Repeat">
            <sig>IEnumerable&lt;T&gt; (T x, int count)</sig>
            <desc>x を count 個だけ含むシーケンスを生成します。</desc>
            <example>
csharp> Enumerable.Repeat(3, 5);
{ 3, 3, 3, 3, 3 }
csharp> var xs = Enumerable.Repeat(new[] { 1, 2 }, 3).ToArray();
csharp> xs
{ { 1, 2 }, { 1, 2 }, { 1, 2 } }
csharp> xs[0][0] = 10; // 要素は共有されます
csharp> xs
{ { 10, 2 }, { 10, 2 }, { 10, 2 } }
            </example>
        </static-method>

        <static-method name="Reverse">
            <sig>IEnumerable&lt;T&gt; &lt;T&gt;(this IEnumerable&lt;T&gt; xs)</sig>
            <desc>
                シーケンスを反転させて返します。
            </desc>
            <example>
csharp> var xs = new[] { 1, 2, 3 };
csharp> xs.Reverse();
{ 3, 2, 1 }
            </example>
        </static-method>

        <static-method name="Select">
        </static-method>

        <static-method name="SelectMany">
            <sig>IEnumerable&lt;U&gt; (this IEnumerable&lt;T&gt; xs, Func&lt;T, IEnumerable&lt;U&gt;&gt; fn)</sig>
            <sig>IEnumerable&lt;U&gt; (this IEnumerable&lt;T&gt; xs, Func&lt;T, int, IEnumerable&lt;U&gt;&gt; fn)</sig>
            <sig>IEnumerable&lt;U&gt; (this IEnumerable&lt;T&gt; xs,
                    Func&lt;T, IEnumerable&lt;M&gt; mfn,
                    Func&lt;T, M, U&gt; rfn)</sig>
            <sig>IEnumerable&lt;U&gt; (this IEnumerable&lt;T&gt; xs,
                    Func&lt;T, int, IEnumerable&lt;M&gt; mfm,
                    Func&lt;T, M, U&gt; rfn)</sig>
            <desc>
                シーケンスのシーケンスを平坦化して返します。
            </desc>
            <example>
class Program {
    static void Main() {
        var xss = new List&lt;int[]&gt;() { new[] { 10, 20, 30 }, new[] { 40, 50 } };

        var a = xss.SelectMany(e => e);
        Console.WriteLine(string.Join(" ", a));
        //=> 10 20 30 40 50

        var b = xss.SelectMany((e, index) => e.Select(v => index));
        Console.WriteLine(string.Join(" ", b));
        //=> 0 0 0 1 1

        var c = xss.SelectMany((e, index) => e.Select(v => Tuple.Create(v, index)));
        Console.WriteLine(string.Join(" ", c));
        //=> (10, 0) (20, 0) (30, 0) (40, 1) (50, 1)

        Func&lt;int[], IEnumerable&lt;int&gt;&gt; identity = e => e;
        Func&lt;int[], int, int&gt; rfn = (xs, v) => xs.Sum() == 60 ? v+1 : v-1;
        // rfn には引数として xss と identity が返すシーケンスが渡されます。
        // rfn の戻り値が SelectMany が返す要素になります。
        var d = xss.SelectMany(identity, rfn);
        Console.WriteLine(string.Join(" ", d));
        //=> 11 21 31 39 49
    }
}
            </example>
        </static-method>

        <static-method name="SequenceEqual">
        </static-method>

        <static-method name="Single">
            <sig>T (this IEnumerable&lt;T&gt; xs)</sig>
            <sig>T (this IEnumerable&lt;T&gt; xs, Func&lt;T, bool&gt; pred)</sig>
            <desc>
                シーケンスに含まれる唯一の要素を返します。

                もしシーケンスに複数の要素が含まれるなら
                InvalidOperationException 例外を生成します。
            </desc>
            <example>
csharp> var xs = new[] { 1234 };
csharp> xs.Single();
1234
csharp> var ys = new[] { 1, 2 };
csharp> ys.Single();
//=> System.InvalidOperationException: Sequence contains more than one element

csharp> new[] { 1, 3, 5, 222 }.Single(e => e % 2 == 0);
222
            </example>
        </static-method>

        <static-method name="SingleOrDefault">
            <sig>T (this IEnumerable&lt;T&gt; xs)</sig>
            <sig>T (this IEnumerable&lt;T&gt; xs, Func&lt;T, bool&gt; pred)</sig>
            <desc>
                シーケンスに含まれる唯一の要素を返します。

                シーケンスが空であれば、既定値 default(T) を返します。
                もしシーケンスに複数の要素が含まれるなら
                InvalidOperationException 例外を生成します。
            </desc>
            <example>
csharp> var xs = new int[0];
csharp> xs.SingleOrDefault();
0
csharp> var ys = new[] { 1, 2 };
csharp> ys.SingleOrDefault();
//=> System.InvalidOperationException: Sequence contains more than one element

csharp> new[] { 1, 2, 3 }.SingleOrDefault(e => e % 2 == 0);
2
csharp> new[] { 1, 3, 5 }.SingleOrDefault(e => e % 2 == 0);
0
            </example>
        </static-method>

        <static-method name="Skip">
            <sig>IEnumerable&lt;T&gt; (this IEnumerable&lt;T&gt; xs, int count)</sig>
            <desc>
                先頭の count 要素を捨てて、残りの要素を返します。
            </desc>
            <example>
csharp> var xs = new[] { 1, 2, 3, 4, 5 };
csharp> xs.Skip(3);
{ 4, 5 }
csharp> xs.Skip(12);
{  }
            </example>
        </static-method>

        <static-method name="SkipWhile">
        </static-method>

        <static-method name="Sum">
            <sig>T (this IEnumerable&lt;T&gt; xs)</sig>
            <sig>U (this IEnumerable&lt;T&gt; xs, Func&lt;T, U&gt;)</sig>
            <desc>
                和を求めます。
            </desc>
            <example>
csharp> var xs = new[] { 1, 2, 3, 4, 5 };
csharp> xs.Sum();
15
csharp> xs.Sum(e => e + 1); // キーの指定も可能
20
            </example>
        </static-method>

        <static-method name="Take">
            <sig>IEnumerable&lt;T&gt; (this IEnumerable&lt;T&gt; xs, int count)</sig>
            <desc>シーケンスの先頭から count 個の要素を返します。</desc>
            <example>
csharp> var xs = new[] { 1, 2, 3, 4, 5 };
csharp> xs.Take(3);
{ 1, 2, 3 }
csharp> xs.Take(2);
{ 1, 2 }
            </example>
        </static-method>

        <static-method name="TakeWhile">
        </static-method>

        <static-method name="ThenBy">
        </static-method>

        <static-method name="ThenByDescending">
        </static-method>

        <static-method name="ToArray">
        </static-method>

        <static-method name="ToDictionary">
        </static-method>

        <static-method name="ToList">
        </static-method>

        <static-method name="ToLookup">
        </static-method>

        <static-method name="Union">
            <sig>IEnumerable&lt;T&gt; (this IEnumerable&lt;T&gt; xs, IEnumerable&lt;T&gt; ys)</sig>
            <sig>IEnumerable&lt;T&gt; (this IEnumerable&lt;T&gt;, IEnumerable&lt;T&gt; ys, IEqualityComparer&lt;T&gt; comparer)</sig>
            <desc>
                二つのシーケンスの和集合を生成します。
            </desc>
            <example>
csharp> var xs = new[] { 1, 2, 3 };
csharp> var ys = new[] { 2, 3, 4 };
csharp> xs.Union(ys);
{ 1, 2, 3, 4 }
            </example>
        </static-method>

        <static-method name="Where">
        </static-method>

        <static-method name="Zip">
        </static-method>
    </class>

    <struct name="Complex">
        <url>https://msdn.microsoft.com/ja-jp/library/system.numerics.complex(v=vs.110).aspx</url>
        <namespace>System.Numerics</namespace>

        <constructor>
            <sig>(double real, double imaginary)</sig>
        </constructor>

        <property name="Imaginary">
        </property>

        <property name="Magnitude">
        </property>

        <property name="Phase">
        </property>

        <property name="Real">
        </property>

        <static-method name="Abs">
            <sig>double (Complex value)</sig>
        </static-method>

        <static-method name="Acos">
            <sig>Complex (Complex value)</sig>
        </static-method>

        <static-method name="Add">
            <sig>Complex (Complex a, Complex b)</sig>
        </static-method>

        <static-method name="Asin">
            <sig>Complex (Complex value)</sig>
        </static-method>

        <static-method name="Atan">
            <sig>Complex (Complex value)</sig>
        </static-method>

        <static-method name="Conjugate">
            <sig>Complex (Complex value)</sig>
        </static-method>

        <static-method name="Cos">
            <sig>Complex (Complex value)</sig>
        </static-method>

        <static-method name="Cosh">
            <sig>Complex (Complex value)</sig>
        </static-method>

        <static-method name="Divide">
            <sig>Complex (Complex dividend, Complex divisor)</sig>
        </static-method>

        <method name="Equals">
            <sig>bool (Complex value)</sig>
            <sig>bool (object obj)</sig>
        </method>

        <static-method name="Exp">
            <sig>Complex (Complex value)</sig>
        </static-method>

        <static-method name="FromPolarCoordinates">
            <sig>Complex (double magnitude, double phase)</sig>
        </static-method>

        <method name="GetHashCode">
        </method>

        <method name="GetType">
        </method>

        <static-method name="Log">
            <sig>Complex (Complex value)</sig>
            <sig>Complex (Complex value, double baseValue)</sig>
        </static-method>

        <static-method name="Log10">
            <sig>Complex (Complex value)</sig>
        </static-method>

        <static-method name="Multiply">
            <sig>Complex (Complex a, Complex b)</sig>
        </static-method>

        <static-method name="Negate">
            <sig>Complex (Complex value)</sig>
        </static-method>

        <static-method name="Pow">
            <sig>Complex (Complex value, Complex power)</sig>
            <sig>Complex (Complex value, double power)</sig>
        </static-method>

        <static-method name="Reciprocal">
            <sig>Complex (Complex value)</sig>
        </static-method>

        <static-method name="Sin">
            <sig>Complex (Complex value)</sig>
        </static-method>

        <static-method name="Sinh">
            <sig>Complex (Complex value)</sig>
        </static-method>

        <static-method name="Sqrt">
            <sig>Complex (Complex value)</sig>
        </static-method>

        <static-method name="Subtract">
            <sig>Complex (Complex a, Complex b)</sig>
        </static-method>

        <static-method name="Tan">
            <sig>Complex (Complex value)</sig>
        </static-method>

        <static-method name="Tanh">
            <sig>Complex (Complex value)</sig>
        </static-method>

        <method name="ToString">
            <sig>string ()</sig>
            <sig>string (IFormatProvider provider)</sig>
            <sig>string (string format)</sig>
            <sig>string (string format, IFormatProvider provider)</sig>
        </method>

        <field name="ImaginaryOne">
        </field>

        <field name="One">
        </field>

        <field name="Zero">
        </field>
    </struct>

    <struct name="Char">
        <url>https://msdn.microsoft.com/ja-jp/library/system.char.aspx</url>
        <namespace>System</namespace>

        <method name="CompareTo">
            <sig>int (char value)</sig>
            <sig>int (object value)</sig>
        </method>

        <static-method name="ConvertFromUtf32">
            <sig>string (int utf32)</sig>
        </static-method>

        <static-method name="ConvertToUtf32">
            <sig>int (char highSurrogate, char lowSurrogate)</sig>
            <sig>int (string s, int index)</sig>
        </static-method>

        <method name="Equals">
            <sig>bool (char obj)</sig>
            <sig>bool (object obj)</sig>
        </method>

        <method name="GetHashCode">
        </method>

        <static-method name="GetNumericValue">
            <sig>double (char c)</sig>
            <sig>double (string s, int index)</sig>
        </static-method>

        <method name="GetType">
        </method>

        <method name="GetTypeCode">
            <sig>TypeCode ()</sig>
        </method>

        <static-method name="GetUnicodeCategory">
            <sig>UnicodeCategory (char c)</sig>
            <sig>UnicodeCategory (string s, int index)</sig>
        </static-method>

        <static-method name="IsControl">
            <sig>bool (char c)</sig>
            <sig>bool (string s, int index)</sig>
        </static-method>

        <static-method name="IsDigit">
            <sig>bool (char c)</sig>
            <sig>bool (string s, int index)</sig>
        </static-method>

        <static-method name="IsHighSurrogate">
            <sig>bool (char c)</sig>
            <sig>bool (string s, int index)</sig>
        </static-method>

        <static-method name="IsLetter">
            <sig>bool (char c)</sig>
            <sig>bool (string s, int index)</sig>
        </static-method>

        <static-method name="IsLetterOrDigit">
            <sig>bool (char c)</sig>
            <sig>bool (string s, int index)</sig>
        </static-method>

        <static-method name="IsLower">
            <sig>bool (char c)</sig>
            <sig>bool (string s, int index)</sig>
        </static-method>

        <static-method name="IsLowSurrogate">
            <sig>bool (char c)</sig>
            <sig>bool (string s, int index)</sig>
        </static-method>

        <static-method name="IsNumber">
            <sig>bool (char c)</sig>
            <sig>bool (string s, int index)</sig>
        </static-method>

        <static-method name="IsPunctuation">
            <sig>bool (char c)</sig>
            <sig>bool (string s, int index)</sig>
        </static-method>

        <static-method name="IsSeparator">
            <sig>bool (char c)</sig>
            <sig>bool (string s, int index)</sig>
        </static-method>

        <static-method name="IsSurrogate">
            <sig>bool (char c)</sig>
            <sig>bool (string s, int index)</sig>
        </static-method>

        <static-method name="IsSurrogatePair">
            <sig>bool (char highSurrogate, char lowSurrogate)</sig>
            <sig>bool (string s, int index)</sig>
        </static-method>

        <static-method name="IsSymbol">
            <sig>bool (char c)</sig>
            <sig>bool (string s, int index)</sig>
        </static-method>

        <static-method name="IsUpper">
            <sig>bool (char c)</sig>
            <sig>bool (string s, int index)</sig>
        </static-method>

        <static-method name="IsWhiteSpace">
            <sig>bool (char c)</sig>
            <sig>bool (string s, int index)</sig>
        </static-method>

        <static-method name="Parse">
            <sig>char (string s)</sig>
        </static-method>

        <static-method name="ToLower">
            <sig>char (char c)</sig>
            <sig>char (char c, CultureInfo culture)</sig>
        </static-method>

        <static-method name="ToLowerInvariant">
            <sig>char (char c)</sig>
        </static-method>

        <method name="ToString">
            <sig>string ()</sig>
            <sig>string (IFormatProvider provider)</sig>
        </method>

        <!--
        <static-method name="ToString">
        </static-method>
          -->

        <static-method name="ToUpper">
            <sig>char (char c)</sig>
            <sig>char (char c, CultureInfo culture)</sig>
        </static-method>

        <static-method name="ToUpperInvariant">
            <sig>char (char c)</sig>
        </static-method>

        <static-method name="TryParse">
            <sig>bool (string s, out char result)</sig>
        </static-method>
    </struct>

    <class name="Regex">
        <url>https://msdn.microsoft.com/ja-jp/library/system.text.regularexpressions.regex(v=vs.110).aspx</url>
        <namespace>System.Text.RegularExpressions</namespace>

        <constructor>
            <sig>()</sig>
            <sig>(SerializationInfo info, StreamingContext context)</sig>
            <sig>(string pattern)</sig>
            <sig>(string pattern, RegexOptions options)</sig>
            <sig>(string pattern, RegexOptions options, TimeSpan matchTimeout)</sig>
        </constructor>

        <property name="CacheSize"></property>
        <property name="MatchTimeout"></property>
        <property name="Options"></property>
        <property name="RightToLeft"></property>

        <static-method name="CompileToAssembly">
        </static-method>

        <method name="Equals">
        </method>

        <static-method name="Escape">
        </static-method>

        <method name="Finalize">
        </method>

        <method name="GetGroupNames">
        </method>

        <method name="GetGroupNumbers">
        </method>

        <method name="GetHashCode">
        </method>

        <method name="GetType">
        </method>

        <method name="GroupNameFromNumber">
        </method>

        <method name="GroupNumberFromName">
        </method>

        <method name="IsMatch">
        </method>

        <!-- TODO:インスタンスメソッドと静的メソッドが同じ場合の対応
        <static-method name="IsMatch">
        </static-method>
          -->

        <method name="Match">
        </method>

        <!--
        <static-method name="Match">
        </static-method>
          -->

        <method name="Matches">
        </method>

        <!--
        <static-method name="Matches">
        </static-method>
          -->

        <method name="MemberwiseClone">
        </method>

        <method name="Replace">
        </method>

        <!--
        <static-method name="Replace">
        </static-method>
          -->

        <method name="Split">
        </method>

        <!--
        <static-method name="Split">
        </static-method>
          -->

        <method name="ToString">
        </method>

        <static-method name="Unescape">
        </static-method>
    </class>

    <struct name="BigInteger">
        <url>https://msdn.microsoft.com/ja-jp/library/system.numerics.biginteger(v=vs.110).aspx</url>
        <namespace>System.Numerics</namespace>

        <constructor>
            <sig>(byte[] value)</sig>
            <sig>(decimal value)</sig>
            <sig>(double value)</sig>
            <sig>(int value)</sig>
            <sig>(long value)</sig>
            <sig>(float value)</sig>
            <sig>(uint value)</sig>
            <sig>(ulong value)</sig>
        </constructor>

        <property name="IsEven">
        </property>

        <property name="IsOne">
        </property>

        <property name="IsPowerOfTwo">
        </property>

        <property name="IsZero">
        </property>

        <property name="MinusOne">
        </property>

        <property name="One">
        </property>

        <property name="Sign">
        </property>

        <property name="Zero">
        </property>

        <static-method name="Abs">
            <sig>BigInteger (BigInteger value)</sig>
        </static-method>

        <static-method name="Add">
            <sig>BigInteger (BigInteger a, BigInteger b)</sig>
        </static-method>

        <static-method name="Compare">
            <sig>int (BigInteger a, BigInteger b)</sig>
        </static-method>

        <method name="CompareTo">
            <sig>int (long other)</sig>
            <sig>int (Object obj)</sig>
            <sig>int (ulong other)</sig>
        </method>

        <static-method name="Divide">
            <sig>BigInteger (BigInteger dividend, BigInteger divisor)</sig>
        </static-method>

        <static-method name="DivRem">
            <sig>BigInteger (BigInteger dividend, BigInteger divisor, out BigInteger remainder)</sig>
        </static-method>

        <method name="Equals">
            <sig>bool (BigInteger other)</sig>
            <sig>bool (long other)</sig>
            <sig>bool (object obj)</sig>
            <sig>bool (ulong other)</sig>
        </method>

        <method name="GetHashCode">
        </method>

        <method name="GetType">
        </method>

        <static-method name="GreatestCommonDivisor">
            <sig>BigInteger (BigInteger a, BigInteger b)</sig>
        </static-method>

        <static-method name="Log">
            <sig>double (BigInteger value)</sig>
            <sig>double (BigInteger value, double baseValue)</sig>
        </static-method>

        <static-method name="Log10">
            <sig>double (BigInteger value)</sig>
        </static-method>

        <static-method name="Max">
            <sig>BigInteger (BigInteger a, BigInteger b)</sig>
        </static-method>

        <static-method name="Min">
            <sig>BigInteger (BigInteger a, BigInteger b)</sig>
        </static-method>

        <static-method name="ModPow">
            <sig>BigInteger (BigInteger value, BigInteger exponent, BigInteger modulus)</sig>
            <desc>value の exponent 乗を modulus で割った余りを求めます。</desc>
        </static-method>

        <static-method name="Multiply">
            <sig>BigInteger (BigInteger a, BigInteger b)</sig>
        </static-method>

        <static-method name="Negate">
            <sig>BigInteger (BigInteger value)</sig>
        </static-method>

        <static-method name="Parse">
            <sig>BigInteger (string value)</sig>
            <sig>BigInteger (string value, IFormatProvider provider)</sig>
            <sig>BigInteger (string value, NumberStyles style)</sig>
            <sig>BigInteger (string value, NumberStyles style, IFormatProvider provider)</sig>
        </static-method>

        <static-method name="Pow">
            <sig>BigInteger (BigInteger value, int exponent)</sig>
        </static-method>

        <static-method name="Remainder">
            <sig>BigInteger (BigInteger dividend, BigInteger divisor)</sig>
        </static-method>

        <static-method name="Subtract">
            <sig>BigInteger (BigInteger a, BigInteger b)</sig>
        </static-method>

        <method name="ToByteArray">
            <sig>byte[] ()</sig>
        </method>

        <method name="ToString">
            <sig>string ()</sig>
            <sig>string (IFormatProvider provider)</sig>
            <sig>string (string format)</sig>
            <sig>string (string format, IFormatProvider provider)</sig>
        </method>

        <static-method name="TryParse">
            <sig>bool (string value, out BigInteger result)</sig>
            <sig>bool (string value, NumberStyles style, IFormatProvider provider, out BigInteger result)</sig>
        </static-method>
    </struct>

    <class name="LinkedList&lt;T&gt;">
        <url>https://msdn.microsoft.com/ja-jp/library/he2s3bh7%28v=vs.110%29.aspx</url>
        <namespace>System.Collections.Generic</namespace>

        <constructor>
            <sig>()</sig>
            <sig>(IEnumerable&lt;T&gt; xs)</sig>
            <sig>(SerializationInfo info, StreamingContext context)</sig>
        </constructor>

        <property name="Count">
        </property>

        <property name="First">
        </property>

        <property name="Last">
        </property>

        <method name="AddAfter">
            <sig>LinkedListNode&lt;T&gt; (LinkedListNode&lt;T&gt; node, T value)</sig>
            <sig>void (LinkedListNode&lt;T&gt; node, LinkedListNode&lt;T&gt; newNode)</sig>
        </method>

        <method name="AddBefore">
            <sig>LinkedListNode&lt;T&gt; (LinkedListNode&lt;T&gt; node, T value)</sig>
            <sig>void (LinkedListNode&lt;T&gt; node, LinkedListNode&lt;T&gt; newNode)</sig>
        </method>

        <method name="AddFirst">
            <sig>LinkedListNode&lt;T&gt; (T value)</sig>
            <sig>void (LinkedListNode&lt;T&gt; node)</sig>
        </method>

        <method name="AddLast">
            <sig>LinkedListNode&lt;T&gt; (T value)</sig>
            <sig>void (LinkedListNode&lt;T&gt; node)</sig>
        </method>

        <method name="Clear">
            <sig>void ()</sig>
        </method>

        <method name="Contains">
            <sig>bool (T value)</sig>
        </method>

        <method name="CopyTo">
            <sig>void (T[] dst, int dstIndex)</sig>
        </method>

        <method name="Equals">
        </method>

        <method name="Finalize">
        </method>

        <method name="Find">
            <sig>LinkedListNode&lt;T&gt; (T value)</sig>
        </method>

        <method name="FindLast">
            <sig>LinkedListNode&lt;T&gt; (T value)</sig>
        </method>

        <method name="GetEnumerator">
            <sig>LinkedList&lt;T&gt;.Enumerator ()</sig>
        </method>

        <method name="GetHashCode">
        </method>

        <method name="GetObjectData">
            <sig>void (SerializationInfo info, StreamingContext context)</sig>
        </method>

        <method name="GetType">
        </method>

        <method name="MemberwiseClone">
        </method>

        <method name="OnDeserialization">
            <sig>void (object sender)</sig>
        </method>

        <method name="Remove">
            <sig>bool (T value)</sig>
            <sig>void (LinkedListNode&lt;T&gt; node)</sig>
        </method>

        <method name="RemoveFirst">
            <sig>void ()</sig>
        </method>

        <method name="RemoveLast">
            <sig>void ()</sig>
        </method>

        <method name="ToString">
        </method>
    </class>

    <class name="SortedSet&lt;T&gt;">
        <url>https://msdn.microsoft.com/ja-jp/library/dd412070(v=vs.110).aspx</url>
        <namespace>System.Collections.Generic</namespace>

        <constructor>
            <sig>()</sig>
            <sig>(IComparer&lt;T&gt; comparer)</sig>
            <sig>(IEnumerable&lt;T&gt; xs)</sig>
            <sig>(IEnumerable&lt;T&gt; xs, IComparer&lt;T&gt; comparer)</sig>
            <sig>(SerializationInfo info, StreamingContext context)</sig>
        </constructor>

        <property name="Comparer">
        </property>

        <property name="Count">
        </property>

        <property name="Max">
        </property>

        <property name="Min">
        </property>

        <method name="Add">
            <sig>bool (T item)</sig>
        </method>

        <method name="Clear">
            <sig>void ()</sig>
        </method>

        <method name="Contains">
            <sig>bool (T item)</sig>
        </method>

        <method name="CopyTo">
            <sig>void (T[] dst)</sig>
            <sig>void (T[] dst, int dstIndex)</sig>
            <sig>void (T[] dst, int dstIndex, int count)</sig>
        </method>

        <static-method name="CreateSetComparer">
            <sig>IEqualityComparer&lt;SortedSet&lt;T&gt;&gt; ()</sig>
            <sig>IEqualityComparer&lt;SortedSet&lt;T&gt;&gt; (IEqualityComparer&lt;T&gt; memberEqualityComparer)</sig>
        </static-method>

        <method name="Equals">
        </method>

        <method name="ExceptWith">
            <sig>void (IEnumerable&lt;T&gt; other)</sig>
        </method>

        <method name="Finalize">
        </method>

        <method name="GetEnumerator">
            <sig>SortedSet&lt;T&gt;.Enumerator ()</sig>
        </method>

        <method name="GetHashCode">
        </method>

        <method name="GetObjectData">
            <sig>void (SerializationInfo info, StreamingContext context)</sig>
        </method>

        <method name="GetType">
        </method>

        <method name="GetViewBetween">
            <sig>SortedSet&lt;T&gt; (T lowerValue, T upperValue)</sig>
        </method>

        <method name="IntersectWith">
            <sig>void (IEnumerable&lt;&gt; other)</sig>
        </method>

        <method name="IsProperSubsetOf">
            <sig>bool (IEnumerable&lt;T&gt; other)</sig>
        </method>

        <method name="IsProperSupersetOf">
            <sig>bool (IEnumerable&lt;T&gt; other)</sig>
        </method>

        <method name="IsSubsetOf">
            <sig>bool (IEnumerable&lt;T&gt; other)</sig>
        </method>

        <method name="IsSupersetOf">
            <sig>bool (IEnumerable&lt;T&gt; other)</sig>
        </method>

        <method name="MemberwiseClone">
        </method>

        <method name="OnDeserialization">
            <sig>void (object sender)</sig>
        </method>

        <method name="Overlaps">
            <sig>bool (IEnumerable&lt;T&gt; other)</sig>
        </method>

        <method name="Remove">
            <sig>bool (T item)</sig>
        </method>

        <method name="RemoveWhere">
            <sig>int (Predicate&lt;T&gt; pred)</sig>
        </method>

        <method name="Reverse">
            <sig>IEnumerable&lt;T&gt; ()</sig>
        </method>

        <method name="SetEquals">
            <sig>bool (IEnumerable&lt;T&gt; other)</sig>
        </method>

        <method name="SymmetricExceptWith">
            <sig>void (IEnumerable&lt;T&gt; other)</sig>
        </method>

        <method name="ToString">
        </method>

        <method name="UnionWith">
            <sig>void (IEnumerable&lt;T&gt; other)</sig>
        </method>
    </class>

    <!-- Rx -->

    <interface name="IObservable&lt;T&gt;">
        <url>https://msdn.microsoft.com/ja-jp/library/dd990377(v=vs.110).aspx</url>
        <namespace>System</namespace>

        <method name="Subscribe">
            <sig>IDisposable (IObserver&lt;T&gt;> observer</sig>
        </method>
    </interface>

    <interface name="IObserver&lt;T&gt;">
        <url>https://msdn.microsoft.com/ja-jp/library/dd783449(v=vs.110).aspx</url>
        <namespace>System</namespace>

        <method name="OnCompleted">
            <sig>void ()</sig>
        </method>

        <method name="OnError">
            <sig>void (Exception error)</sig>
        </method>

        <method name="OnNext">
            <sig>void (T value)</sig>
        </method>
    </interface>

    <class name="Subject&lt;T&gt;">
        <url>https://msdn.microsoft.com/en-us/library/hh229173(v=vs.103).aspx</url>
        <namespace>System.Reactive.Subjects</namespace>

        <method name="Dispose">
            <sig>void ()</sig>
        </method>

        <method name="Equals">
        </method>

        <method name="Finalize">
        </method>

        <method name="GetHashCode">
        </method>

        <method name="GetType">
        </method>

        <method name="MemberwiseClone">
        </method>

        <method name="OnCompleted">
            <sig>void ()</sig>
        </method>

        <method name="OnError">
            <sig>void (Exception error)</sig>
        </method>

        <method name="OnNext">
            <sig>void (T value)</sig>
        </method>

        <method name="Subscribe">
            <sig>IDisposable (IObserver&lt;T&gt; observer)</sig>
        </method>

        <method name="ToString">
        </method>

    </class>

    <class name="Observable">
        <url>https://msdn.microsoft.com/en-us/library/system.reactive.linq.observable(v=vs.103).aspx</url>
        <namespace>System.Reactive.Linq</namespace>

        <static-method name="Aggregate">
        </static-method>

        <static-method name="All">
        </static-method>

        <static-method name="Amb">
        </static-method>

        <static-method name="And">
        </static-method>

        <static-method name="Any">
        </static-method>

        <static-method name="AsObservable">
        </static-method>

        <static-method name="Average">
        </static-method>

        <static-method name="Buffer">
        </static-method>

        <static-method name="Cast">
        </static-method>

        <static-method name="Catch">
        </static-method>

        <static-method name="CombineLatest">
        </static-method>

        <static-method name="Concat">
        </static-method>

        <static-method name="Contains">
        </static-method>

        <static-method name="Count">
        </static-method>

        <static-method name="Create">
        </static-method>

        <static-method name="DefaultIfEmpty">
        </static-method>

        <static-method name="Defer">
        </static-method>

        <static-method name="Delay">
        </static-method>

        <static-method name="Dematerialize">
        </static-method>

        <static-method name="Distinct">
        </static-method>

        <static-method name="DistinctUntilChanged">
        </static-method>

        <static-method name="Do">
        </static-method>

        <static-method name="ElementAt">
        </static-method>

        <static-method name="ElementAtOrDefault">
        </static-method>

        <static-method name="Empty">
        </static-method>

        <static-method name="Finally">
        </static-method>

        <static-method name="First">
        </static-method>

        <static-method name="FirstOrDefault">
        </static-method>

        <static-method name="ForEach">
        </static-method>

        <static-method name="FromAsyncPattern">
        </static-method>

        <static-method name="FromEvent">
        </static-method>

        <static-method name="FromEventPattern">
        </static-method>

        <static-method name="Generate">
        </static-method>

        <static-method name="GetEnumerator">
        </static-method>

        <static-method name="GroupBy">
        </static-method>

        <static-method name="GroupByUntil">
        </static-method>

        <static-method name="GroupJoin">
        </static-method>

        <static-method name="IgnoreElements">
        </static-method>

        <static-method name="Interval">
        </static-method>

        <static-method name="Join">
        </static-method>

        <static-method name="Last">
        </static-method>

        <static-method name="LastOfDefault">
        </static-method>

        <static-method name="Latest">
        </static-method>

        <static-method name="LongCount">
        </static-method>

        <static-method name="Materialize">
        </static-method>

        <static-method name="Max">
        </static-method>

        <static-method name="MaxBy">
        </static-method>

        <static-method name="Merge">
        </static-method>

        <static-method name="Min">
        </static-method>

        <static-method name="MinBy">
        </static-method>

        <static-method name="MostRecent">
        </static-method>

        <static-method name="Multicast">
        </static-method>

        <static-method name="Never">
        </static-method>

        <static-method name="Next">
        </static-method>

        <static-method name="ObserveOn">
        </static-method>

        <static-method name="OfType">
        </static-method>

        <static-method name="OnErrorResumeNext">
        </static-method>

        <static-method name="Publish">
        </static-method>

        <static-method name="Range">
        </static-method>

        <static-method name="RefCount">
        </static-method>

        <static-method name="Repeat">
        </static-method>

        <static-method name="Replay">
        </static-method>

        <static-method name="Retry">
        </static-method>

        <static-method name="Return">
        </static-method>

        <static-method name="Sample">
        </static-method>

        <static-method name="Scan">
        </static-method>

        <static-method name="Select">
        </static-method>

        <static-method name="SelectMany">
        </static-method>

        <static-method name="SequenceEqual">
        </static-method>

        <static-method name="Single">
        </static-method>

        <static-method name="SingleOrDefault">
        </static-method>

        <static-method name="Skip">
        </static-method>

        <static-method name="SkipLast">
        </static-method>

        <static-method name="SkipUntil">
        </static-method>

        <static-method name="SkipWhile">
        </static-method>

        <static-method name="Start">
        </static-method>

        <static-method name="StartWith">
        </static-method>

        <static-method name="Subscribe">
        </static-method>

        <static-method name="SubscribeOn">
        </static-method>

        <static-method name="Sum">
        </static-method>

        <static-method name="Switch">
        </static-method>

        <static-method name="Synchronize">
        </static-method>

        <static-method name="Take">
        </static-method>

        <static-method name="TakeLast">
        </static-method>

        <static-method name="TakeUntil">
        </static-method>

        <static-method name="TakeWhile">
        </static-method>

        <static-method name="Then">
        </static-method>

        <static-method name="Throttle">
        </static-method>

        <static-method name="Throw">
        </static-method>

        <static-method name="TimeInterval">
        </static-method>

        <static-method name="Timeout">
        </static-method>

        <static-method name="Timer">
        </static-method>

        <static-method name="Timestamp">
        </static-method>

        <static-method name="ToArray">
        </static-method>

        <static-method name="ToAsync">
        </static-method>

        <static-method name="ToDictionary">
        </static-method>

        <static-method name="ToEnumerable">
        </static-method>

        <static-method name="ToEvent">
        </static-method>

        <static-method name="ToEventPattern">
        </static-method>

        <static-method name="ToList">
        </static-method>

        <static-method name="ToLookup">
        </static-method>

        <static-method name="ToObservable">
        </static-method>

        <static-method name="Using">
        </static-method>

        <static-method name="When">
        </static-method>

        <static-method name="Where">
        </static-method>

        <static-method name="Window">
        </static-method>

        <static-method name="Zip">
        </static-method>
    </class>

    <class name="BehaviorSubject&lt;T&gt;">
        <url>https://msdn.microsoft.com/en-us/library/hh211949%28v=vs.103%29.aspx</url>
        <namespace>System.Reactive.Subjects</namespace>
    </class>

    <class name="ReplaySubject&lt;T&gt;">
        <url>https://msdn.microsoft.com/en-us/library/hh211810%28v=vs.103%29.aspx</url>
        <namespace>System.Reactive.Subjects</namespace>
    </class>

    <class name="AsyncSubject&lt;T&gt;">
        <url>https://msdn.microsoft.com/en-us/library/system.reactive.subjects%28v=vs.103%29.aspx</url>
        <namespace>System.Reactive.Subjects</namespace>
    </class>

    <class name="CompositeDisposable">
        <url>https://msdn.microsoft.com/en-us/library/system.reactive.disposables.compositedisposable(v=vs.103).aspx</url>
        <namespace>System.Reactive.Disposables</namespace>
    </class>
</cs>

