<?xml version="1.0"?>
<cs>
    <!--

    class : クラス名
    interface : インターフェース名
    url : MSDN の URL

    constructor : コンストラクタ
    field : フィールド
    property : プロパティ
    static-method : static メソッド
    method : インスタンスメソッド

      -->

    <!--

    TODO: SortedSet, BigInteger, Regex

      -->

    <class name="Math">
        <url>https://msdn.microsoft.com/ja-jp/library/system.math%28v=vs.110%29.aspx</url>

        <field name="E">
            <desc></desc>
        </field>

        <field name="PI">
        </field>

        <static-method name="Abs">
        </static-method>

        <static-method name="Acos">
        </static-method>

        <static-method name="Asin">
        </static-method>

        <static-method name="Atan">
        </static-method>

        <static-method name="Atan2">
        </static-method>

        <static-method name="BigMul">
        </static-method>

        <static-method name="Celling">
        </static-method>

        <static-method name="Cos">
        </static-method>

        <static-method name="Cosh">
        </static-method>

        <static-method name="DivRem">
            <sig>int (int a, int b, out int m)</sig>
            <desc>商と余りを求めます。</desc>
            <example>
csharp> var m = 0;
csharp> Math.DivRem(10, 3, out m);
3
csharp> m
1
            </example>
        </static-method>

        <static-method name="Exp">
        </static-method>

        <static-method name="Floor">
        </static-method>

        <static-method name="IEEERemainder">
        </static-method>

        <static-method name="Log">
        </static-method>

        <static-method name="Log10">
        </static-method>

        <static-method name="Max">
        </static-method>

        <static-method name="Min">
        </static-method>

        <static-method name="Pow">
        </static-method>

        <static-method name="Round">
        </static-method>

        <static-method name="Sign">
        </static-method>

        <static-method name="Sin">
        </static-method>

        <static-method name="Sinh">
        </static-method>

        <static-method name="Sqrt">
        </static-method>

        <static-method name="Tan">
        </static-method>

        <static-method name="Tanh">
        </static-method>

        <static-method name="Truncate">
        </static-method>

    </class>

    <class name="List">
        <url>https://msdn.microsoft.com/ja-jp/library/6sh2ey19%28v=vs.110%29.aspx</url>

        <property name="Capacity">
        </property>

        <property name="Count">
        </property>

        <property name="Item">
        </property>

        <method name="Add">
        </method>

        <method name="AddRange">
            <sig>void (IEnumerable&lt;T&gt; xs)</sig>
            <desc>
                指定したシーケンスの要素を末尾に追加します。
            </desc>
            <example>
csharp> var xs = new List&lt;int&gt;();
csharp> xs.AddRange(new[] { 1, 2, 3 });
csharp> xs
{ 1, 2, 3 }
            </example>
        </method>

        <method name="AsReadOnly">
        </method>

        <method name="BinarySearch">
        </method>

        <method name="Clear">
        </method>

        <method name="Contains">
        </method>

        <method name="ConvertAll">
        </method>

        <method name="CopyTo">
        </method>

        <method name="Equals">
        </method>

        <method name="Exists">
        </method>

        <method name="Finalize">
        </method>

        <method name="Find">
            <sig>T (Predicate&lt;T&gt; pred)</sig>
            <desc>
                pred にマッチする最初の要素を返します。
                見つからない場合は、T の既定値を返します。
            </desc>
            <example>
csharp> var ls = new List&lt;int&gt;() { 3, 22 };
csharp> ls.Find(e => e == 3);
3
csharp> ls.Find(e => e > 10);
22
csharp> ls.Find(e => e == 10); // int の既定値が返る
0
            </example>
        </method>

        <method name="FindAll">
            <sig>List&lt;T&gt; (Predicate&lt;T&gt; pred)</sig>
            <desc>
                pred にマッチする全ての要素をリストにして返します。
            </desc>
            <example>
csharp> var xs = new List&lt;int&gt;() { 1, 2, 3, 4, 5 };
csharp> xs.FindAll(e => e % 2 == 0);
{ 2, 4 }
            </example>
        </method>

        <method name="FindIndex">
            <sig>int (Predicate&gt;T&gt; pred)</sig>
            <sig>int (int startIndex, Predicate&lt;T&gt; pred)</sig>
            <sig>int (int startIndex, int count, Predicate&lt;T&gt; pred)</sig>
            <desc>
                pred にマッチする要素を検索します。
                最初に見つかる要素のインデックスを返します。
                見つからなければ -1 を返します。

                引数 startIndex: 検索の開始インデックス
                引数 count: 検索する要素数
            </desc>

            <example>
csharp> var xs = new List&lt;int&gt;() { 1, 2, 3, 4, 5 };
csharp> xs.FindIndex(e => e > 2);
2
csharp> xs.FindIndex(2, e => e > 3); // xs[2] 以降の要素を検索
3
csharp> xs.FindIndex(2, e => e &lt; 3); // xs[2] 以降で 3 より小さな要素は存在しない
-1
            </example>
        </method>

        <method name="FindLast">
        </method>

        <method name="FindLastIndex">
        </method>

        <method name="ForEach">
        </method>

        <method name="GetEnumerator">
        </method>

        <method name="GetHashCode">
        </method>

        <method name="GetRange">
        </method>

        <method name="GetType">
        </method>

        <method name="IndexOf">
            <sig>int (T item)</sig>
            <sig>int (T item, int startIndex)</sig>
            <sig>int (T item, int startIndex, int count)</sig>
            <desc>
                指定したオブジェクトを検索します。
                最初に見つかったオブジェクトのインデックスを返します。
                見つからなければ -1 を返します。

                引数 startIndex: 検索の開始位置インデックス
                引数 count: 検索する要素数
            </desc>
            <example>
csharp> var xs = new List&lt;int&gt;() { 1, 2, 3, 4, 5 };
csharp> xs.IndexOf(3);
2
csharp> xs.IndexOf(3, 3);
-1
csharp> xs.IndexOf(5, 0, 1);
-1
            </example>
        </method>

        <method name="Insert">
            <sig>void (int index, T item)</sig>
            <desc>
                指定したインデックスに要素を挿入します。
            </desc>
            <example>
csharp> var xs = new List&lt;int&gt;() { 1, 2, 3 };
csharp> xs.Insert(1, 100);
csharp> xs
{ 1, 100, 2, 3 }
            </example>
        </method>

        <method name="InsertRange">
        </method>

        <method name="LastIndexOf">
        </method>

        <method name="MemberwiseClone">
        </method>

        <method name="Remove">
            <sig>bool (T item)</sig>
        </method>

        <method name="RemoveAll">
        </method>

        <method name="RemoveAt">
            <sig>void (int index)</sig>
        </method>

        <method name="RemoveRange">
        </method>

        <method name="Reverse">
        </method>

        <method name="Sort">
            <sig>void ()</sig>
            <sig>void (Comparison&lt;T&gt; comparison)</sig>
            <sig>void (IComparer&lt;T&gt; comparer)</sig>
            <sig>void (int index, int count, IComparer&lt;T&gt; comparer)</sig>
            <desc>
                ソートします。
            </desc>
            <example>
csharp> var xs = new List&lt;string&gt;() { "class", "string", "list" };
csharp> xs.Sort();
csharp> xs
{ "class", "list", "string" }
csharp> xs.Sort((a, b) => a.Length.CompareTo(b.Length));
csharp> xs
{ "list", "class", "string" }
csharp>
            </example>
        </method>

        <method name="ToArray">
        </method>

        <method name="ToString">
        </method>

        <method name="TrimExcess">
        </method>

        <method name="TrueForAll">
        </method>
    </class>

    <class name="String">
        <url>https://msdn.microsoft.com/ja-jp/library/system.string(v=vs.110).aspx</url>

        <constructor>
        </constructor>

        <field name="Empty">
        </field>

        <property name="Chars">
            <desc>
                public char this[int index] { get; }
            </desc>
        </property>

        <property name="Length">
        </property>

        <method name="Clone">
        </method>

        <method name="Compare">
        </method>

        <method name="CompareTo">
        </method>

        <static-method name="Concat">
            <sig>string (object o)</sig>
            <sig>string (object o, object o2)</sig>
            <sig>string (object o, object o2, object o3)</sig>
            <sig>string (object o, object o2, object o3, object o4)</sig>
            <sig>string (object[] objs)</sig>
            <sig>string (string s)</sig>
            <sig>string (string s, string s2)</sig>
            <sig>string (string s, string s2, string s3)</sig>
            <sig>string (string s, string s2, string s3, string s4)</sig>
            <sig>string (string[] ss)</sig>
            <sig>string (IEnumerable&lt;T&gt; xs)</sig>
            <desc>
                指定したオブジェクトを文字列形式で連結します。
            </desc>
            <example>
csharp> string.Concat(1, "foo");
"1foo"
csharp> string.Concat(new[] { 1, 2, 3 });
"123"
            </example>
        </static-method>

        <method name="Contains">
        </method>

        <method name="Copy">
        </method>


        <method name="CopyTo">
        </method>

        <method name="EndsWith">
            <sig>bool (string value)</sig>
            <sig>bool (string value, StringComparison type)</sig>
            <sig>bool (string value, bool ignoreCase, CultureInfo culture)</sig>
        </method>

        <method name="Equals">
        </method>

        <static-method name="Format">
        </static-method>

        <method name="GetEnumerator">
        </method>

        <method name="GetHashCode">
        </method>

        <method name="GetType">
        </method>

        <method name="GetTypeCode">
        </method>

        <method name="IndexOf">
            <sig>int (char   value)</sig>
            <sig>int (string value)</sig>
            <sig>int (char   value, int startIndex)</sig>
            <sig>int (string value, int startIndex)</sig>
            <sig>int (string value, StringComparison type)</sig>
            <sig>int (char   value, int startIndex, int count)</sig>
            <sig>int (string value, int startIndex, int count)</sig>
            <sig>int (string value, int startIndex, StringComparison type)</sig>
            <sig>int (string value, int startIndex, int count, StringComparison type)</sig>
            <desc>
                文字、または文字列を検索する。最初に見つかったインデックスを返します。
                見つからなければ、-1 を返します。
            </desc>
            <example>
csharp> var s = "abcd-abcd";
csharp> s.IndexOf('-');
4
csharp> s.IndexOf("zz");
-1
csharp> s.IndexOf("a", 1); // インデックス 1 から検索する
5
csharp> s.IndexOf('a');
0
            </example>
        </method>

        <method name="IndexOfAny">
            <sig>int (char[] anyOf)</sig>
            <sig>int (char[] anyOf, int startIndex)</sig>
            <sig>int (char[] anyOf, int startIndex, int count)</sig>
            <desc>
                引数の文字配列のいずれかの文字を検索する。
                最初に見つかった文字のインデックスを返す。
                見つからなければ、-1 を返す。
            </desc>
            <example>
sharp> var s = "hello world";
csharp> s.IndexOfAny("or".ToCharArray());
4
csharp> s.IndexOfAny("ab".ToCharArray());
-1
            </example>
        </method>

        <method name="Insert">
            <sig>string (int startIndex, string value)</sig>
            <desc>
                startIndex に文字列 value を挿入した新しい文字列を返します。
                元の文字列は変更されません。
            </desc>
            <example>
csharp> var s = "hello world"
csharp> s.Insert(2, "abc");
"heabcllo world"
csharp> s
"hello world"
            </example>
        </method>

        <static-method name="Intern">
        </static-method>

        <static-method name="IsInterned">
        </static-method>

        <method name="IsNormalized">
        </method>

        <static-method name="IsNullOrEmpty">
        </static-method>

        <static-method name="IsNullOrWhiteSpace">
        </static-method>

        <static-method name="Join">
        </static-method>

        <method name="LastIndexOf">
            <desc>
                IndexOf() と同じだが、最後に見つかった文字、文字列のインデックスを返す。
                見つからなければ、-1 を返す。
            </desc>
        </method>

        <method name="LastIndexOfAny">
            <desc>
                IndexOfAny() と同じだが、再顔に見つかった文字、文字列のインデックスを返す。
                見つからなければ、-1 を返す。
            </desc>
        </method>

        <method name="Normalize">
        </method>

        <method name="PadLeft">
            <sig>string (int totalWidth)</sig>
            <sig>string (int totalWidth, char paddingChar)</sig>
            <example>
csharp> var s = "abc";
csharp> s.PadLeft(5);
"  abc"
csharp> s.PadLeft(5, '-');
"--abc"
            </example>
        </method>

        <method name="PadRight">
            <sig>string (int totalWidth)</sig>
            <sig>string (int totalWidth, char paddingChar)</sig>
            <example>
csharp> var s = "abc";
csharp> s.PadRight(5);
"abc  "
csharp> s.PadRight(5, '-');
"abc--"
            </example>
        </method>

        <method name="Remove">
            <sig>string (int startIndex)</sig>
            <sig>string (int startIndex, int count)</sig>
            <desc>
                startIndex 以降の文字列を取り除いた新しい文字列を返します。
            </desc>
            <example>
csharp> var s = "helloworld";
csharp> s.Remove(2);
"he"
csharp> s
"helloworld"
csharp> s.Remove(2, 3);
"heworld"
            </example>
        </method>

        <method name="Replace">
            <sig>string (char oldChar, char newChar)</sig>
            <sig>string (string oldValue, string newValue)</sig>
            <example>
csharp> "abcabc".Replace("abc", "def"); // 全ての文字列が置換される
"defdef"
csharp> "hello world".Replace('o', '-'); // 全ての文字が置換される
"hell- w-rld"
            </example>
        </method>

        <method name="Split">
        </method>

        <method name="StartsWith">
            <sig>bool (string value)</sig>
            <sig>bool (string value, StringComparison type)</sig>
            <sig>bool (string value, bool ignoreCase, CultureInfo culture)</sig>
        </method>

        <method name="Substring">
            <sig>string (int startIndex)</sig>
            <sig>string (int startIndex, int length)</sig>
            <example>
csharp> var s = "abc-def";
csharp> s.Substring(3);
"-def"
csharp> s.Substring(3, 2);
"-d"
            </example>
        </method>

        <method name="ToCharArray">
        </method>

        <method name="ToLower">
        </method>

        <method name="ToLowerInvariant">
        </method>

        <method name="ToString">
        </method>

        <method name="ToUpper">
        </method>

        <method name="ToUpperInvariant">
        </method>

        <method name="Trim">
        </method>

        <method name="TrimEnd">
        </method>

        <method name="TrimStart">
        </method>

    </class>

    <class name="Array">
        <static-method name="AsReadOnly">
        </static-method>

        <static-method name="BinarySearch">
        </static-method>

        <static-method name="Clear">
        </static-method>

        <static-method name="Clone">
        </static-method>

        <static-method name="ConstrainedCopy">
        </static-method>

        <static-method name="ConvertAll">
        </static-method>

		<static-method name="Copy">
			<sig>void (Array src, Array dst, int length)</sig>
			<sig>void (Array src, Array dst, long length)</sig>
			<sig>void (Array src, int srcIndex, Array dst, int dstIndex, int length)</sig>
			<sig>void (Array src, long srcIndex, Array dst, long dstIndex, long length)</sig>
			<desc>
				配列をコピーします。
			</desc>
			<example>
csharp> var xs = new int[] { 1, 23, 456 };
csharp> var ys = new int[xs.Length];
csharp> ys
{ 0, 0, 0 }
csharp> Array.Copy(xs, ys, xs.Length); // xs を ys へコピーする
csharp> ys
{ 1, 23, 456 }
csharp> Array.Copy(xs, 1, ys, 0, 2); //  xs の 1 番目から、ys の 0 番目へ
                                     //  要素 2 つ分コピーする
csharp> ys
{ 23, 456, 456 }
			</example>

        </static-method>

		<method name="CopyTo">
			<sig>void (Array dst, int dstStartIndex)</sig>
			<sig>void (Array dst, long dstStartIndex)</sig>
			<desc>
				配列をコピーします。
				引数には、コピー先の配列と、コピー先のコピー開始位置を指定します。
				コピー先の要素数が足りない場合は、System.ArgumentException が生成されます。
			</desc>
			<example>
csharp> var xs = new int[] { 1, 23, 456 };
csharp> var ys = new int[xs.Length];
csharp> ys
{ 0, 0, 0 }
csharp> xs.CopyTo(ys, 0); // xs を ys の 0 番目からコピーする

csharp> var zs = new int[xs.Length + 1];
csharp> zs
{ 0, 0, 0, 0 }
csharp> xs.CopyTo(zs, 1); // xs を zs の 1 番目からコピーする
csharp> zs
{ 0, 1, 23, 456 }
csharp> xs.CopyTo(zs, 2); // System.ArgumentException が発生する(要素数が足りないため)。
			</example>


        </method>

        <static-method name="CreateInstance">
        </static-method>

        <static-method name="Equals">
        </static-method>

        <static-method name="Exists">
        </static-method>

        <static-method name="Finalize">
        </static-method>

        <static-method name="Find">
        </static-method>

        <static-method name="FindAll">
        </static-method>

        <static-method name="FindIndex">
        </static-method>

        <static-method name="FindLast">
        </static-method>

        <static-method name="FindLastIndex">
        </static-method>

        <static-method name="ForEach">
        </static-method>

        <method name="GetEnumerator">
        </method>

        <method name="GetHashCode">
        </method>

        <method name="GetLength">
        </method>

        <method name="GetongLength">
        </method>

        <method name="GetLowerBound">
        </method>

        <method name="GetType">
        </method>

        <method name="GetUpperBound">
        </method>

        <method name="GetValue">
        </method>

        <static-method name="IndexOf">
        </static-method>

        <method name="Initialize">
        </method>

        <static-method name="LastIndexOf">
        </static-method>

        <method name="MemberwiseClone">
        </method>

        <static-method name="Resize">
        </static-method>

        <static-method name="Reverse">
        </static-method>

        <method name="SetValue">
        </method>

        <static-method name="Sort">
        </static-method>

        <method name="ToString">
        </method>

        <static-method name="TrueForAll">
        </static-method>
    </class>

    <class name="Dictionary">
        <method name="Add">
        </method>

        <method name="Clear">
        </method>

        <method name="ContainsKey">
        </method>

        <method name="ContainsValue">
        </method>

        <method name="Equals">
        </method>

        <method name="Finalize">
        </method>

        <method name="GetEnumerator">
        </method>

        <method name="GetHashCode">
        </method>

        <method name="GetObjectData">
        </method>

        <method name="GetType">
        </method>

        <method name="MemberwiseClone">
        </method>

        <method name="OnDeserialization">
        </method>

        <method name="Remove">
        </method>

        <method name="ToString">
        </method>

        <method name="TryGetValue">
        </method>

        <property name="Comparer">
        </property>

        <property name="Count">
        </property>

        <property name="Item">
        </property>

        <property name="Keys">
        </property>

        <property name="Values">
        </property>

    </class>

    <class name="HashSet">
        <method name="Add">
        </method>

        <method name="Clear">
        </method>

        <method name="Contains">
        </method>

        <method name="CopyTo">
        </method>

        <static-method name="CreateSetComparer">
        </static-method>

        <method name="Equals">
        </method>

        <method name="ExceptWith">
        </method>

        <method name="Finalize">
        </method>

        <method name="GetEnumerator">
        </method>

        <method name="GetHashCode">
        </method>

        <method name="GetObjectData">
        </method>

        <method name="GetType">
        </method>

        <method name="IntersectWith">
        </method>

        <method name="IsProperSubsetOf">
        </method>

        <method name="IsProperSupersetOf">
        </method>

        <method name="IsSubsetOf">
        </method>

        <method name="IsSupersetOf">
        </method>

        <method name="MemberwiseClone">
        </method>

        <method name="OnDeserialization">
        </method>

        <method name="Overlaps">
        </method>

        <method name="Remove">
        </method>

        <method name="RemoveWhere">
        </method>

		<method name="SetEquals">
			<sig>bool (IEnumerable&lt;T&gt; other)</sig>
			<desc>other の要素と一致するなら true を返します。</desc>
			<example>
csharp> var hs = new HashSet&lt;int&gt;() { 1, 2, 3 };
csharp> hs.SetEquals(hs);
true
csharp> hs.SetEquals(new[] { 2, 3, 1 });
true
csharp> hs.SetEquals(new[] { 2, 3 });
false
csharp> hs.SetEquals(new[] { 2, 3, 1, 4 });
false
			</example>
        </method>

        <method name="SymmetricExceptWith">
        </method>

        <method name="ToString">
        </method>

        <method name="TrimExcess">
        </method>

        <method name="UnionWith">
        </method>

        <property name="Comparer">
        </property>

        <property name="Count">
        </property>

    </class>


    <class name="Stack">
        <url>https://msdn.microsoft.com/ja-jp/library/3278tedw(v=vs.110).aspx</url>

        <method name="Clear">
            <sig>void ()</sig>
            <desc>スタックを空にします。</desc>
            <example>
csharp> var s = new Stack&lt;int&gt;(new[] { 1, 2, 3 });
csharp> s
{ 3, 2, 1 }
csharp> s.Clear();
csharp> s
{  }
            </example>

        </method>

        <method name="Contains">
        </method>

        <method name="CopyTo">
        </method>

        <method name="Equals">
        </method>

        <method name="Finalize">
        </method>

        <method name="GetEnumerator">
        </method>

        <method name="GetHashCode">
        </method>

        <method name="GetType">
        </method>

        <method name="MemberwiseClone">
        </method>

        <method name="Peek">
        </method>

        <method name="Pop">
        </method>

        <method name="Push">
        </method>

        <method name="ToArray">
        </method>

        <method name="ToString">
        </method>

        <method name="TrimExcess">
        </method>

        <property name="Count">
        </property>
    </class>

    <class name="Queue">
        <method name="Clear">
        </method>

        <method name="Contains">
        </method>

        <method name="CopyTo">
        </method>

        <method name="Dequeue">
        </method>

        <method name="Enqueue">
        </method>

        <method name="Equals">
        </method>

        <method name="Finalize">
        </method>

        <method name="GetEnumerator">
        </method>

        <method name="GetHashCode">
        </method>

        <method name="GetType">
        </method>

        <method name="MemberwiseClone">
        </method>

        <method name="Peek">
        </method>

        <method name="ToArray">
        </method>

        <method name="ToString">
        </method>

        <method name="TrimExcess">
        </method>

        <property name="Count">
        </property>
    </class>

    <class name="Random">
        <method name="Equals">
        </method>

        <method name="Finalize">
        </method>

        <method name="GetHashCode">
        </method>

        <method name="GetType">
        </method>

        <method name="MemberwiseClone">
        </method>

        <method name="Next">
            <sig>int ()</sig>
            <sig>int (int maxValue)</sig>
            <sig>int (int minValue, int maxValue)</sig>
            <desc>
                引数なしの場合は、0 以上、int.MaxValue 未満の int を返します。
                引数一つの場合は、0 以上、maxValue 未満の int を返します。
                引数二つの場合は、minValue 以上、maxValue 未満の int を返します。
            </desc>
        </method>

        <method name="NextBytes">
            <sig>void (byte[] buffer)</sig>
            <desc>
                引数 buffer にランダムなバイトを格納します。
            </desc>
        </method>

        <method name="NextDouble">
            <sig>double ()</sig>
            <desc>
                0.0 以上、1.0 未満の double を返します。
            </desc>
        </method>

        <method name="Sample">
            <sig>double ()</sig>
            <desc>
                0.0 以上、1.0 未満の double を返します。

                (このメソッドは protected です。代わりに NextDouble メソッドを使用します)
            </desc>
        </method>

        <method name="ToString">
        </method>

    </class>

    <class name="Enumerable">
        <url>https://msdn.microsoft.com/ja-jp/library/system.linq.enumerable_methods(v=vs.110).aspx</url>

        <static-method name="Aggregate">
        </static-method>

        <static-method name="All">
            <sig>bool (this IEnumerable&lt;T&gt; xs, Func&lt;T, bool&gt; pred)</sig>
            <desc>
                全ての要素が pred を満たすかどうか調べます。
            </desc>
            <example>
csharp> var xs = new[] { 1, 2, 3, 4, 5 };
csharp> xs.All(e => e > 0); // 全ての要素は、0 より大きいか
true
csharp> xs.All(e => e % 2 == 0); // 全ての要素は、偶数か
false
            </example>

        </static-method>

        <static-method name="Any">
            <sig>bool Any()</sig>
            <sig>bool Any(this IEnumerable&lt;T&gt; xs, Func&lt;T, bool&gt; pred)</sig>
            <desc>
                シーケンスに要素が含まれるか調べます。

                引数 pred: pred を満たす要素が含まれるか調べます。
            </desc>
            <example>
csharp> new[] { false }.Any();
true
csharp> new int[0].Any();
false
csharp> new[] { 1, 3, 5 }.Any(e => e % 2 == 0);
false
csharp> new[] { 1, 3, 5 }.Any(e => e == 3);
true
            </example>
        </static-method>

        <static-method name="AsEnumerable">
        </static-method>

        <static-method name="Average">
        </static-method>

        <static-method name="Cast">
        </static-method>

        <static-method name="Concat">
        </static-method>

        <static-method name="Contains">
            <sig>bool (IEnumerable&lt;T&gt; xs, T val)</sig>
            <sig>bool (IEnumerable&lt;T&gt; xs, T val, IEqualityComparer&lt;T&gt; comparer)</sig>
            <desc>
                指定した要素がシーケンスに含まれるか判定します。
            </desc>
            <example>
csharp> var xs = new[] { 1, 3, 5, 7 };
csharp> xs.Contains(2);
false
csharp> xs.Contains(5);
true
            </example>

        </static-method>

		<static-method name="Count">
			<sig>int (this IEnumerable&lt;T&gt; xs)</sig>
			<sig>int (this IEnumerable&lt;T&gt; xs, Func&lt;T, bool&gt; pred</sig>
			<desc>要素数を返します。</desc>
			<example>
csharp> var xs = new List&lt;int&gt;() { -9, 9, 34, 9 }
csharp> xs.Count();
4
csharp> xs.Count(e => e == 9);
2
			</example>
        </static-method>

        <static-method name="DefaultIfEmpty">
            <sig>IEnumerable&lt;T&gt; (IEnumerable&lt;T&gt; xs)</sig>
            <sig>IEnumerable&lt;T&gt; (IEnumerable&lt;T&gt; xs, T defaultValue)</sig>
            <desc>
                シーケンスが空ならば、T の規定値をひとつ含むシーケンスを返します。
                シーケンスが空でなければ、シーケンスをそのまま返します。

                引数 defaultValue: シーケンスが空の場合の規定値
            </desc>
            <example>
csharp> var xs = new List&lt;int&gt;();
csharp> xs.DefaultIfEmpty();
{ 0 }
csharp> xs.DefaultIfEmpty(123);
{ 123 }
csharp> new[] { 10, 20 }.DefaultIfEmpty();
{ 10, 20 }
            </example>
        </static-method>

        <static-method name="Distinct">
        </static-method>

        <static-method name="ElementAt">
            <sig>T (this IEnumerable&lt;T&gt; xs, int index)</sig>
            <desc>指定されたインデックスの要素を返します。</desc>
            <example>
csharp> var xs = new[] { 1, 2, 3 };
csharp> xs.ElementAt(0);
1
csharp> xs.ElementAt(1);
2
            </example>
        </static-method>

        <static-method name="ElementAtOrDefault">
        </static-method>

        <static-method name="Except">
        </static-method>

        <static-method name="First">
            <sig>T (this IEnumerable&lt;T&gt; xs)</sig>
            <sig>T (this IEnumerable&lt;T&gt; xs, Func&lt;T, bool&gt; pred)</sig>
            <desc>
                最初の要素を返します。
                シーケンスが空だったり、pred にマッチする要素が見つからない場合は、
                InvalidOperationException 例外が生成されます。
            </desc>
            <example>
csharp> var xs = new[] { 1, 2, 3, 4, 5 };
csharp> xs.First();
1
csharp> xs.First(e => e >= 3);
3
            </example>
        </static-method>

        <static-method name="FirstOrDefault">
            <sig>T (this IEnumerable&lt;T&gt; xs)</sig>
            <sig>T (this IEnumerable&lt;T&gt; xs, Func&lt;T, bool&gt; pred)</sig>
            <desc>
                最初の要素を返します。
                シーケンスが空だったり、pred にマッチする要素が見つからない場合は、
                規定値を返します。
                規定値を指定するには、DefaultIfEmpty() を使います。
            </desc>
            <example>
csharp> var xs = new int[0];
csharp> xs.FirstOrDefault();
0
csharp> new[] { 1, 2, 3 }.FirstOrDefault(e => e > 100);
0
csharp> xs.DefaultIfEmpty(100).First();
100
            </example>
        </static-method>

        <static-method name="GroupBy">
        </static-method>

        <static-method name="GroupJoin">
        </static-method>

        <static-method name="Intersect">
        </static-method>

        <static-method name="Join">
        </static-method>

        <static-method name="Last">
            <sig>T (this IEnumerable&lt;T&gt; xs)</sig>
            <sig>T (this IEnumerable&lt;T&gt; xs, Func&lt;T, bool&gt; pred)</sig>
            <desc>
                最後の要素を返します。
                シーケンスが空だったり、pred にマッチする要素が見つからない場合は、
                InvalidOperationException 例外が生成されます。
            </desc>
            <example>
csharp> var xs = new[] { 1, 2, 3, 4, 5 };
csharp> xs.Last();
5
csharp> xs.Last(e => e &lt;= 3);
3
            </example>

        </static-method>

        <static-method name="LastOrDefault">
            <sig>T (this IEnumerable&lt;T&gt; xs)</sig>
            <sig>T (this IEnumerable&lt;T&gt; xs, Func&lt;T, bool&gt; pred)</sig>
            <desc>
                最後の要素を返します。
                シーケンスが空だったり、pred にマッチする要素が見つからない場合は、
                規定値を返します。
                規定値を指定するには、DefaultIfEmpty() を使います。
            </desc>
            <example>
csharp> var xs = new int[0];
csharp> xs.LastOrDefault();
0
csharp> new[] { 1, 2, 3 }.LastOrDefault(e => e > 100);
0
csharp> xs.DefaultIfEmpty(100).Last();
100
            </example>
        </static-method>

        <static-method name="LongCount">
        </static-method>

        <static-method name="Max">
        </static-method>

        <static-method name="Min">
        </static-method>

        <static-method name="OfType">
        </static-method>

        <static-method name="OrderBy">
        </static-method>

        <static-method name="OrderByDescending">
        </static-method>

        <static-method name="Range">
        </static-method>

        <static-method name="Repeat">
        </static-method>

        <static-method name="Reverse">
        </static-method>

        <static-method name="Select">
        </static-method>

        <static-method name="SelectMany">
            <sig>IEnumerable&lt;U&gt; (this IEnumerable&lt;T&gt; xs, Func&lt;T, IEnumerable&lt;U&gt;&gt; fn)</sig>
            <sig>IEnumerable&lt;U&gt; (this IEnumerable&lt;T&gt; xs, Func&lt;T, int, IEnumerable&lt;U&gt;&gt; fn)</sig>
            <sig>IEnumerable&lt;U&gt; (this IEnumerable&lt;T&gt; xs,
                    Func&lt;T, IEnumerable&lt;M&gt; mfn,
                    Func&lt;T, M, U&gt; rfn)</sig>
            <sig>IEnumerable&lt;U&gt; (this IEnumerable&lt;T&gt; xs,
                    Func&lt;T, int, IEnumerable&lt;M&gt; mfm,
                    Func&lt;T, M, U&gt; rfn)</sig>
            <desc>
                シーケンスのシーケンスを平坦化して返します。
            </desc>
            <example>
class Program {
    static void Main() {
        var xss = new List&lt;int[]&gt;() { new[] { 10, 20, 30 }, new[] { 40, 50 } };

        var a = xss.SelectMany(e => e);
        Console.WriteLine(string.Join(" ", a));
        //=> 10 20 30 40 50

        var b = xss.SelectMany((e, index) => e.Select(v => index));
        Console.WriteLine(string.Join(" ", b));
        //=> 0 0 0 1 1

        var c = xss.SelectMany((e, index) => e.Select(v => Tuple.Create(v, index)));
        Console.WriteLine(string.Join(" ", c));
        //=> (10, 0) (20, 0) (30, 0) (40, 1) (50, 1)

        Func&lt;int[], IEnumerable&lt;int&gt;&gt; identity = e => e;
        Func&lt;int[], int, int&gt; rfn = (xs, v) => xs.Sum() == 60 ? v+1 : v-1;
        // rfn には引数として xss と identity が返すシーケンスが渡されます。
        // rfn の戻り値が SelectMany が返す要素になります。
        var d = xss.SelectMany(identity, rfn);
        Console.WriteLine(string.Join(" ", d));
        //=> 11 21 31 39 49
    }
}
            </example>
        </static-method>

        <static-method name="SequenceEqual">
        </static-method>

        <static-method name="Single">
        </static-method>

        <static-method name="SingleOrDefault">
        </static-method>

        <static-method name="Skip">
            <sig>IEnumerable&lt;T&gt; (this IEnumerable&lt;T&gt; xs, int count)</sig>
            <desc>
                先頭の count 要素を捨てて、残りの要素を返します。
            </desc>
            <example>
csharp> var xs = new[] { 1, 2, 3, 4, 5 };
csharp> xs.Skip(3);
{ 4, 5 }
csharp> xs.Skip(12);
{  }
            </example>
        </static-method>

        <static-method name="SkipWhile">
        </static-method>

        <static-method name="Sum">
            <sig>T (this IEnumerable&lt;T&gt; xs)</sig>
            <sig>U (this IEnumerable&lt;T&gt; xs, Func&lt;T, U&gt;)</sig>
            <desc>
                和を求めます。
            </desc>
            <example>
csharp> var xs = new[] { 1, 2, 3, 4, 5 };
csharp> xs.Sum();
15
csharp> xs.Sum(e => e + 1); // キーの指定も可能
20
            </example>
        </static-method>

        <static-method name="Take">
        </static-method>

        <static-method name="TakeWhile">
        </static-method>

        <static-method name="ThenBy">
        </static-method>

        <static-method name="ThenByDescending">
        </static-method>

        <static-method name="ToArray">
        </static-method>

        <static-method name="ToDictionary">
        </static-method>

        <static-method name="ToList">
        </static-method>

        <static-method name="ToLookup">
        </static-method>

        <static-method name="Union">
            <sig>IEnumerable&lt;T&gt; (this IEnumerable&lt;T&gt; xs, IEnumerable&lt;T&gt; ys)</sig>
            <sig>IEnumerable&lt;T&gt; (this IEnumerable&lt;T&gt;, IEnumerable&lt;T&gt; ys, IEqualityComparer&lt;T&gt; comparer)</sig>
            <desc>
                二つのシーケンスの和集合を生成します。
            </desc>
            <example>
csharp> var xs = new[] { 1, 2, 3 };
csharp> var ys = new[] { 2, 3, 4 };
csharp> xs.Union(ys);
{ 1, 2, 3, 4 }
            </example>
        </static-method>

        <static-method name="Where">
        </static-method>

        <static-method name="Zip">
        </static-method>
    </class>

</cs>

